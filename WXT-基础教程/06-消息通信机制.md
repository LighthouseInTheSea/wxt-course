# 消息通信机制

> **导航**: [目录](../README.md) | [上一篇: 05-内容脚本开发](./05-内容脚本开发.md) | [下一篇: 07-Storage存储系统](./07-Storage存储系统.md)
>
> **实战练习**: [06-消息通信实战](../WXT-实战练习/06-消息通信实战.md)
>
> **官方文档**: https://wxt.dev/guide/essentials/messaging.html

---

## 前言

浏览器扩展由多个独立的组件组成,它们运行在完全隔离的环境中。消息通信是这些组件之间交换数据的唯一方式。

理解消息机制对于开发复杂扩展至关重要。本章将全面讲解各种通信场景和最佳实践。

---

## 1. 通信概述

浏览器扩展的组件运行在不同的上下文中:

```
+------------------+
|   Background     |<--+
| (Service Worker) |   |
+--------+---------+   |
         |             |
    消息通信           消息通信
         |             |
+--------v---------+   |
|  Content Script  |   |
+--------+---------+   |
         |             |
    DOM 操作           |
         |             |
+--------v---------+   |
|    Web Page      |---+
+------------------+
         |
    消息通信
         |
+--------v---------+
|     Popup        |
|    Options       |
|    Sidepanel     |
+------------------+
```

**关键概念**:
- 每个组件都是独立的 JavaScript 运行时
- 组件之间不能直接调用函数或访问变量
- 所有通信都通过浏览器提供的消息 API 进行
- 消息内容必须是可序列化的(JSON 兼容)

---

## 2. 基础消息 API

### 2.1 发送消息

从任意位置发送消息到后台脚本:

```typescript
// 发送消息并等待响应
const response = await browser.runtime.sendMessage({
  type: 'GREETING',
  data: 'Hello from content script',
});
console.log('Response:', response);
```

**代码解析**:
- `browser.runtime.sendMessage()` 发送消息到后台脚本
- 这是一个 Promise,返回后台脚本的响应
- 消息对象可以是任意 JSON 兼容的数据

### 2.2 接收消息

在后台脚本中监听消息:

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
    // message: 接收到的消息对象
    // sender: 发送者信息(包含标签页 ID、URL 等)
    // sendResponse: 用于发送响应的函数
    
    console.log('Message received:', message);
    console.log('From:', sender.tab?.url);
    
    // 同步响应
    sendResponse({ status: 'ok', data: 'Hello back!' });
    
    // 返回 true 表示会异步响应
    return false; // false 表示同步响应
  });
});
```

### 2.3 异步响应

当需要异步处理(如调用 API)时:

```typescript
browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
  // 异步处理消息
  handleMessageAsync(message).then((result) => {
    sendResponse(result);
  });
  
  // 重要: 返回 true 表示会异步调用 sendResponse
  // 否则消息通道会立即关闭
  return true;
});

async function handleMessageAsync(message: any) {
  // 模拟 API 调用
  await new Promise(resolve => setTimeout(resolve, 1000));
  return { status: 'completed', data: message };
}
```

**常见错误**: 忘记 `return true` 导致异步响应失效。

---

## 3. 向特定标签页发送消息

### 3.1 从后台发送到内容脚本

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  // 向特定标签页发送消息
  async function sendToTab(tabId: number, message: any) {
    try {
      const response = await browser.tabs.sendMessage(tabId, message);
      console.log('Tab response:', response);
      return response;
    } catch (error) {
      // 可能的错误:
      // - 标签页没有内容脚本
      // - 内容脚本未准备好
      // - 标签页已关闭
      console.error('Failed to send message to tab:', error);
    }
  }
  
  // 示例: 点击扩展图标时发送消息到当前标签页
  browser.action.onClicked.addListener(async (tab) => {
    if (tab.id) {
      await sendToTab(tab.id, { type: 'TOGGLE_FEATURE' });
    }
  });
});
```

**注意**: `browser.tabs.sendMessage` 只能发送到内容脚本,不能发送到网页本身。

### 3.2 广播到所有标签页

```typescript
async function broadcastToAllTabs(message: any) {
  // 获取所有标签页
  const tabs = await browser.tabs.query({});
  
  const results = [];
  for (const tab of tabs) {
    if (tab.id) {
      try {
        const response = await browser.tabs.sendMessage(tab.id, message);
        results.push({ tabId: tab.id, response });
      } catch {
        // 某些标签页可能没有内容脚本,忽略错误
      }
    }
  }
  
  return results;
}
```

---

## 4. 类型安全的消息系统

手动管理消息类型容易出错。以下是一个类型安全的消息系统实现:

### 4.1 定义消息类型

```typescript
// utils/messages.ts

// 定义所有消息及其请求/响应类型
export interface Messages {
  // 翻译请求
  'translate': {
    request: { text: string; targetLang: string };
    response: { translatedText: string };
  };
  
  // 获取设置
  'getSettings': {
    request: void;  // 无需参数
    response: { theme: string; enabled: boolean };
  };
  
  // 切换功能
  'toggleFeature': {
    request: { featureId: string };
    response: { success: boolean };
  };
}

// 辅助类型
export type MessageType = keyof Messages;

export type MessageRequest<T extends MessageType> = {
  type: T;
  data: Messages[T]['request'];
};

export type MessageResponse<T extends MessageType> = Messages[T]['response'];
```

### 4.2 类型安全的发送函数

```typescript
// utils/messages.ts

export async function sendMessage<T extends MessageType>(
  type: T,
  data: Messages[T]['request']
): Promise<Messages[T]['response']> {
  return browser.runtime.sendMessage({ type, data });
}

// 使用示例
const result = await sendMessage('translate', {
  text: 'Hello',
  targetLang: 'zh',
});
// TypeScript 自动推断 result 类型为 { translatedText: string }
```

### 4.3 类型安全的监听器

```typescript
// utils/messages.ts

type MessageHandler<T extends MessageType> = (
  data: Messages[T]['request'],
  sender: Browser.runtime.MessageSender
) => Messages[T]['response'] | Promise<Messages[T]['response']>;

// 存储处理器
const handlers = new Map<MessageType, MessageHandler<any>>();

// 注册处理器
export function onMessage<T extends MessageType>(
  type: T,
  handler: MessageHandler<T>
) {
  handlers.set(type, handler);
}

// 全局监听器(只需注册一次)
browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
  const handler = handlers.get(message.type);
  if (handler) {
    const result = handler(message.data, sender);
    if (result instanceof Promise) {
      result.then(sendResponse);
      return true; // 异步响应
    }
    sendResponse(result);
  }
  return false;
});
```

### 4.4 使用示例

```typescript
// entrypoints/background.ts
import { onMessage } from '~/utils/messages';

export default defineBackground(() => {
  // 注册翻译处理器
  onMessage('translate', async (data) => {
    // data 类型自动推断为 { text: string; targetLang: string }
    const translatedText = await translateAPI(data.text, data.targetLang);
    return { translatedText };
  });
  
  // 注册设置处理器
  onMessage('getSettings', () => {
    return { theme: 'dark', enabled: true };
  });
});
```

```typescript
// entrypoints/content.ts
import { sendMessage } from '~/utils/messages';

export default defineContentScript({
  matches: ['<all_urls>'],
  
  async main() {
    // 完全类型安全的调用
    const settings = await sendMessage('getSettings', undefined);
    console.log('Theme:', settings.theme); // 自动补全
    
    const result = await sendMessage('translate', {
      text: 'Hello world',
      targetLang: 'zh',
    });
    console.log('Translated:', result.translatedText);
  },
});
```

---

## 5. 与网页通信

内容脚本与网页是隔离的,需要特殊方式通信。

### 5.1 使用 window.postMessage

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['<all_urls>'],
  
  main() {
    // 接收来自页面的消息
    window.addEventListener('message', (event) => {
      // 安全验证
      if (event.source !== window) return;
      if (event.data?.source !== 'my-extension-page') return;
      
      console.log('Message from page:', event.data);
      
      // 回复页面
      window.postMessage({
        source: 'my-extension-content',
        data: { status: 'received' },
      }, '*');
    });
  },
});
```

```typescript
// entrypoints/injected.ts (注入到页面主世界)
export default defineUnlistedScript(() => {
  // 发送消息到内容脚本
  window.postMessage({
    source: 'my-extension-page',
    data: { action: 'getData' },
  }, '*');
  
  // 接收回复
  window.addEventListener('message', (event) => {
    if (event.data?.source === 'my-extension-content') {
      console.log('Reply:', event.data);
    }
  });
});
```

### 5.2 使用 CustomEvent

```typescript
// 内容脚本发送事件
document.dispatchEvent(new CustomEvent('extension-message', {
  detail: { action: 'update', data: { value: 123 } },
}));

// 页面脚本监听
document.addEventListener('extension-message', (event: CustomEvent) => {
  console.log('Event from extension:', event.detail);
});
```

---

## 6. 长连接 (Port)

对于需要频繁或持续通信的场景,使用 Port 比反复发送消息更高效。

### 6.1 建立连接

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['<all_urls>'],
  
  main() {
    // 建立到后台的持久连接
    const port = browser.runtime.connect({ name: 'content-script' });
    
    // 通过连接发送消息
    port.postMessage({ type: 'INIT', url: window.location.href });
    
    // 接收消息
    port.onMessage.addListener((message) => {
      console.log('Received:', message);
    });
    
    // 监听断开(如后台重启)
    port.onDisconnect.addListener(() => {
      console.log('Disconnected from background');
      // 可以尝试重新连接
    });
  },
});
```

### 6.2 后台处理连接

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  // 存储所有活动连接
  const connections = new Map<number, Browser.runtime.Port>();
  
  browser.runtime.onConnect.addListener((port) => {
    console.log('New connection:', port.name);
    
    // 存储连接(可选)
    const tabId = port.sender?.tab?.id;
    if (tabId) {
      connections.set(tabId, port);
    }
    
    // 接收消息
    port.onMessage.addListener((message) => {
      console.log('Message:', message);
      
      // 处理并回复
      port.postMessage({ type: 'ACK', received: message });
    });
    
    // 清理断开的连接
    port.onDisconnect.addListener(() => {
      console.log('Port disconnected:', port.name);
      if (tabId) {
        connections.delete(tabId);
      }
    });
  });
  
  // 向所有连接广播
  function broadcast(message: any) {
    for (const port of connections.values()) {
      port.postMessage(message);
    }
  }
});
```

---

## 7. 扩展页面间通信

### 7.1 Popup 与后台通信

```typescript
// entrypoints/popup/App.tsx
import { useState, useEffect } from 'react';

function App() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // 组件挂载时从后台获取数据
    browser.runtime.sendMessage({ type: 'GET_DATA' })
      .then(setData)
      .finally(() => setLoading(false));
  }, []);
  
  const handleClick = async () => {
    const result = await browser.runtime.sendMessage({
      type: 'PERFORM_ACTION',
      data: { /* ... */ },
    });
    console.log('Result:', result);
  };
  
  if (loading) return <div>Loading...</div>;
  
  return (
    <div>
      <pre>{JSON.stringify(data, null, 2)}</pre>
      <button onClick={handleClick}>Execute Action</button>
    </div>
  );
}
```

---

## 8. 外部消息 (网站到扩展)

允许特定网站直接与你的扩展通信。

### 8.1 配置 externally_connectable

```typescript
// wxt.config.ts
export default defineConfig({
  manifest: {
    externally_connectable: {
      matches: [
        'https://your-website.com/*',
        'https://*.your-domain.com/*',
      ],
    },
  },
});
```

### 8.2 网站发送消息

```javascript
// 在你的网站页面中
const extensionId = 'your-extension-id'; // 从扩展管理页获取

chrome.runtime.sendMessage(extensionId, {
  type: 'FROM_WEBSITE',
  data: { action: 'getData' },
}, (response) => {
  console.log('Response from extension:', response);
});
```

### 8.3 扩展接收外部消息

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  browser.runtime.onMessageExternal.addListener(
    (message, sender, sendResponse) => {
      console.log('External message from:', sender.url);
      
      // 验证来源
      if (!sender.url?.startsWith('https://your-website.com')) {
        sendResponse({ error: 'Unauthorized' });
        return;
      }
      
      // 处理消息
      sendResponse({ status: 'ok', data: message });
    }
  );
});
```

---

## 9. 最佳实践

### 9.1 错误处理

```typescript
async function safeSendMessage(message: any) {
  try {
    return await browser.runtime.sendMessage(message);
  } catch (error) {
    // 常见错误:
    // - "Could not establish connection" - 后台不存在或未监听
    // - "The message port closed" - 接收方未响应
    // - "Extension context invalidated" - 扩展已更新/卸载
    console.error('Message failed:', error);
    return null;
  }
}
```

### 9.2 消息验证

```typescript
browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
  // 验证消息格式
  if (!message || typeof message.type !== 'string') {
    sendResponse({ error: 'Invalid message format' });
    return;
  }
  
  // 验证发送者
  if (sender.tab) {
    // 来自内容脚本
    console.log('From tab:', sender.tab.url);
  } else {
    // 来自扩展页面(popup, options 等)
    console.log('From extension page');
  }
  
  return true;
});
```

### 9.3 避免循环消息

```typescript
// 使用消息 ID 防止重复处理
const processedMessages = new Set<string>();

browser.runtime.onMessage.addListener((message) => {
  if (message.id && processedMessages.has(message.id)) {
    return; // 已处理
  }
  
  if (message.id) {
    processedMessages.add(message.id);
    // 清理旧消息 ID
    if (processedMessages.size > 1000) {
      const oldest = processedMessages.values().next().value;
      processedMessages.delete(oldest);
    }
  }
  
  // 处理消息...
});
```

---

## 10. 小结

| 方法 | 用途 | 方向 |
|------|------|------|
| `runtime.sendMessage` | 发送到后台 | 任意 -> 后台 |
| `tabs.sendMessage` | 发送到标签页 | 后台 -> 内容脚本 |
| `runtime.connect` | 长连接 | 双向 |
| `window.postMessage` | 页面通信 | 内容脚本 <-> 页面 |
| `runtime.onMessageExternal` | 外部消息 | 网站 -> 扩展 |

**选择建议**:
- 简单的请求/响应: 使用 `sendMessage`
- 频繁通信: 使用 `connect` 建立长连接
- 与页面 JS 通信: 使用 `postMessage`
- 与自己的网站通信: 使用 `onMessageExternal`

---

> **下一步**: 学习 [07-Storage存储系统](./07-Storage存储系统.md),了解如何持久化存储数据
