# WXT 远程代码与脚本注入

## 1. 概述

Manifest V3 对远程代码有严格限制,不允许执行从网络加载的代码。WXT 提供了解决方案:

1. **url: 前缀**: 在构建时下载并捆绑远程脚本
2. **Unlisted Scripts**: 创建可注入页面主世界的脚本
3. **injectScript()**: 从内容脚本注入脚本到页面

## 2. 使用 url: 前缀捆绑远程代码

### 2.1 基本用法

通过 `url:` 前缀导入远程脚本,WXT 会在构建时下载并捆绑:

```typescript
// utils/google-analytics.ts
import 'url:https://www.googletagmanager.com/gtag/js?id=G-XXXXXX';

// 声明全局变量
declare global {
  interface Window {
    dataLayer: any[];
    gtag: (...args: any[]) => void;
  }
}

window.dataLayer = window.dataLayer || [];
window.gtag = function() {
  window.dataLayer.push(arguments);
};

window.gtag('js', new Date());
window.gtag('config', 'G-XXXXXX');
```

### 2.2 在入口点中使用

```typescript
// entrypoints/popup/main.ts
import '~/utils/google-analytics';

// 现在可以使用 gtag
window.gtag('event', 'popup_opened', {
  event_category: 'engagement',
});
```

### 2.3 适用场景

- Google Analytics / Tag Manager
- 第三方 SDK
- CDN 上的库文件

## 3. Unlisted Scripts (未列出脚本)

### 3.1 什么是 Unlisted Script

Unlisted Script 是不会出现在 manifest.json 中的脚本,主要用于:

- 注入到页面主世界 (Main World)
- 拦截页面 JavaScript
- 访问页面全局变量

### 3.2 创建 Unlisted Script

```typescript
// entrypoints/injected.ts
export default defineUnlistedScript(() => {
  console.log('Running in main world!');
  
  // 访问页面变量
  console.log('Page title:', document.title);
  console.log('Window location:', window.location.href);
  
  // 监听页面事件
  window.addEventListener('message', (event) => {
    if (event.data.type === 'FROM_EXTENSION') {
      console.log('Received from extension:', event.data);
    }
  });
});
```

### 3.3 带导出的 Unlisted Script

```typescript
// entrypoints/injected.ts
export default defineUnlistedScript({
  main() {
    console.log('Injected script loaded');
    
    // 修改页面行为
    const originalFetch = window.fetch;
    window.fetch = async function(...args) {
      console.log('Fetch intercepted:', args[0]);
      return originalFetch.apply(this, args);
    };
  },
});
```

## 4. 使用 injectScript() 注入脚本

### 4.1 基本注入

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['*://*.example.com/*'],
  
  async main(ctx) {
    // 注入 unlisted script
    await injectScript('/injected.js');
    console.log('Script injected!');
  },
});
```

### 4.2 注入选项

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['*://*.example.com/*'],
  
  async main(ctx) {
    await injectScript('/injected.js', {
      keepInDom: true,  // 保持 script 标签在 DOM 中
    });
  },
});
```

### 4.3 配置 Web Accessible Resources

注入的脚本必须是可访问的:

```typescript
// wxt.config.ts
export default defineConfig({
  manifest: {
    web_accessible_resources: [
      {
        resources: ['injected.js'],
        matches: ['*://*.example.com/*'],
      },
    ],
  },
});
```

## 5. 完整示例: 页面变量拦截器

### 5.1 项目结构

```
entrypoints/
├── content.ts           # 内容脚本
├── injected.ts          # 注入脚本
└── background.ts        # 后台脚本
```

### 5.2 注入脚本

```typescript
// entrypoints/injected.ts
export default defineUnlistedScript(() => {
  // 拦截 XMLHttpRequest
  const originalXHROpen = XMLHttpRequest.prototype.open;
  XMLHttpRequest.prototype.open = function(method, url, ...rest) {
    console.log(`[XHR] ${method} ${url}`);
    
    // 发送消息给内容脚本
    window.postMessage({
      type: 'XHR_INTERCEPTED',
      method,
      url: url.toString(),
    }, '*');
    
    return originalXHROpen.apply(this, [method, url, ...rest]);
  };
  
  // 拦截 fetch
  const originalFetch = window.fetch;
  window.fetch = async function(input, init) {
    const url = typeof input === 'string' ? input : input.url;
    const method = init?.method || 'GET';
    
    console.log(`[Fetch] ${method} ${url}`);
    
    window.postMessage({
      type: 'FETCH_INTERCEPTED',
      method,
      url,
    }, '*');
    
    return originalFetch.apply(this, [input, init]);
  };
  
  console.log('Network interceptors installed!');
});
```

### 5.3 内容脚本

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['<all_urls>'],
  runAt: 'document_start',
  
  async main(ctx) {
    // 注入拦截脚本
    await injectScript('/injected.js');
    
    // 监听来自注入脚本的消息
    window.addEventListener('message', (event) => {
      if (event.source !== window) return;
      
      if (event.data.type === 'XHR_INTERCEPTED' || 
          event.data.type === 'FETCH_INTERCEPTED') {
        // 转发给后台脚本
        browser.runtime.sendMessage({
          action: 'NETWORK_REQUEST',
          data: event.data,
        });
      }
    });
  },
});
```

### 5.4 后台脚本

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  const requestLog: Array<{
    type: string;
    method: string;
    url: string;
    timestamp: number;
  }> = [];
  
  browser.runtime.onMessage.addListener((message, sender) => {
    if (message.action === 'NETWORK_REQUEST') {
      requestLog.push({
        ...message.data,
        timestamp: Date.now(),
      });
      
      console.log('Network request logged:', message.data);
    }
  });
});
```

### 5.5 配置

```typescript
// wxt.config.ts
export default defineConfig({
  manifest: {
    permissions: ['activeTab'],
    web_accessible_resources: [
      {
        resources: ['injected.js'],
        matches: ['<all_urls>'],
      },
    ],
  },
});
```

## 6. 内容脚本与注入脚本通信

### 6.1 使用 postMessage

```typescript
// entrypoints/injected.ts
export default defineUnlistedScript(() => {
  // 监听来自内容脚本的消息
  window.addEventListener('message', (event) => {
    if (event.data.type === 'GET_PAGE_DATA') {
      // 获取页面数据
      const pageData = {
        title: document.title,
        url: window.location.href,
        // 访问页面 JS 变量
        customData: (window as any).myAppData,
      };
      
      // 回复内容脚本
      window.postMessage({
        type: 'PAGE_DATA_RESPONSE',
        data: pageData,
      }, '*');
    }
  });
});
```

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['*://*.example.com/*'],
  
  async main(ctx) {
    await injectScript('/injected.js');
    
    // 请求页面数据
    const getPageData = (): Promise<any> => {
      return new Promise((resolve) => {
        const handler = (event: MessageEvent) => {
          if (event.data.type === 'PAGE_DATA_RESPONSE') {
            window.removeEventListener('message', handler);
            resolve(event.data.data);
          }
        };
        
        window.addEventListener('message', handler);
        window.postMessage({ type: 'GET_PAGE_DATA' }, '*');
      });
    };
    
    const pageData = await getPageData();
    console.log('Page data:', pageData);
  },
});
```

### 6.2 使用 CustomEvent

```typescript
// entrypoints/injected.ts
export default defineUnlistedScript(() => {
  // 使用自定义事件
  document.addEventListener('extension:request', (event: CustomEvent) => {
    const { action, payload } = event.detail;
    
    if (action === 'getConfig') {
      const config = (window as any).APP_CONFIG;
      
      document.dispatchEvent(new CustomEvent('extension:response', {
        detail: { action, data: config },
      }));
    }
  });
});
```

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['*://*.example.com/*'],
  
  async main(ctx) {
    await injectScript('/injected.js');
    
    // 发送请求
    const request = <T>(action: string, payload?: any): Promise<T> => {
      return new Promise((resolve) => {
        const handler = (event: CustomEvent) => {
          if (event.detail.action === action) {
            document.removeEventListener('extension:response', handler);
            resolve(event.detail.data);
          }
        };
        
        document.addEventListener('extension:response', handler as EventListener);
        document.dispatchEvent(new CustomEvent('extension:request', {
          detail: { action, payload },
        }));
      });
    };
    
    const config = await request<{ apiUrl: string }>('getConfig');
    console.log('App config:', config);
  },
});
```

## 7. Unlisted Pages (未列出页面)

### 7.1 创建 Unlisted Page

```html
<!-- entrypoints/welcome.html -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Welcome</title>
</head>
<body>
  <div id="root"></div>
  <script type="module" src="./main.tsx"></script>
</body>
</html>
```

```tsx
// entrypoints/welcome/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')!).render(<App />);
```

### 7.2 打开 Unlisted Page

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  // 安装时打开欢迎页
  browser.runtime.onInstalled.addListener(({ reason }) => {
    if (reason === 'install') {
      const url = browser.runtime.getURL('/welcome.html');
      browser.tabs.create({ url });
    }
  });
  
  // 通过命令打开
  browser.commands?.onCommand.addListener((command) => {
    if (command === 'open-welcome') {
      const url = browser.runtime.getURL('/welcome.html');
      browser.tabs.create({ url });
    }
  });
});
```

## 8. 安全最佳实践

### 8.1 验证消息来源

```typescript
// entrypoints/content.ts
window.addEventListener('message', (event) => {
  // 只接受来自同一窗口的消息
  if (event.source !== window) return;
  
  // 验证消息类型
  if (!event.data.type?.startsWith('MY_EXTENSION_')) return;
  
  // 处理消息
  handleMessage(event.data);
});
```

### 8.2 限制 Web Accessible Resources

```typescript
// wxt.config.ts
export default defineConfig({
  manifest: {
    web_accessible_resources: [
      {
        resources: ['injected.js'],
        // 只允许特定网站访问
        matches: [
          'https://example.com/*',
          'https://*.example.org/*',
        ],
      },
    ],
  },
});
```

### 8.3 避免敏感信息泄露

```typescript
// entrypoints/injected.ts
export default defineUnlistedScript(() => {
  // 不要在注入脚本中包含敏感信息
  // 敏感操作应该在后台脚本中执行
  
  // 错误: 不要这样做
  // const API_KEY = 'secret-key';
  
  // 正确: 通过消息请求敏感操作
  window.postMessage({
    type: 'PERFORM_SECURE_ACTION',
    data: { /* 非敏感数据 */ },
  }, '*');
});
```

## 9. 小结

| 技术 | 用途 | 运行环境 |
|------|------|----------|
| url: 前缀 | 捆绑远程脚本 | 扩展上下文 |
| defineUnlistedScript | 创建可注入脚本 | 页面主世界 |
| injectScript() | 注入脚本到页面 | - |
| Unlisted Pages | 创建未列出的 HTML 页面 | 扩展上下文 |

关键点:
- 远程代码必须在构建时捆绑
- 注入脚本运行在页面主世界,可以访问页面变量
- 内容脚本和注入脚本通过 postMessage 通信
- 注意配置 web_accessible_resources
