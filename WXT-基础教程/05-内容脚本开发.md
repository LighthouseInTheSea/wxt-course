# 内容脚本开发 (Content Scripts)

> **导航**: [目录](../README.md) | [上一篇: 04-后台脚本开发](./04-后台脚本开发.md) | [下一篇: 06-消息通信机制](./06-消息通信机制.md)
>
> **实战练习**: [05-内容脚本实战](../WXT-实战练习/05-内容脚本实战.md)
>
> **官方文档**: https://wxt.dev/guide/essentials/content-scripts.html

---

## 前言

内容脚本(Content Scripts)是浏览器扩展最核心的功能之一。它允许你将 JavaScript 代码注入到用户访问的网页中,从而实现:

- 修改网页外观(如暗黑模式、广告屏蔽)
- 提取网页数据(如价格比较、翻译)
- 增强网页功能(如视频倍速、快捷键)
- 与后台服务通信(如同步数据、调用 API)

本章将从基础到高级,全面讲解内容脚本的开发技巧。

---

## 1. 内容脚本概述

内容脚本是注入到网页中运行的 JavaScript 代码,可以:
- 读取和修改网页 DOM
- 向网页注入 UI 元素
- 与后台脚本通信
- 拦截和修改网页行为

### 1.1 运行环境

**关键概念**: 内容脚本运行在"隔离世界"中,这是浏览器为扩展提供的安全机制。

| 环境 | 说明 | 能访问什么 | 不能访问什么 |
|------|------|------------|--------------|
| **隔离世界 (ISOLATED)** | 默认模式 | DOM、扩展 API | 页面 JS 变量 |
| **主世界 (MAIN)** | 特殊模式 | DOM、页面 JS 变量 | 扩展 API |

**为什么需要隔离?**
1. **安全性**: 防止恶意网页读取扩展数据
2. **稳定性**: 避免与页面脚本冲突(如 jQuery 版本不同)
3. **可预测性**: 扩展代码行为不受页面影响

---

## 2. 基础内容脚本

### 2.1 最简形式

每个内容脚本都需要通过 `defineContentScript` 函数定义。最基本的配置只需要 `matches` 和 `main`:

```typescript
// entrypoints/content.ts
export default defineContentScript({
  // matches: 指定脚本在哪些网站上运行
  // 这里表示在所有 Google 页面上运行
  matches: ['*://*.google.com/*'],
  
  // main: 脚本的入口函数,页面加载时自动执行
  main() {
    console.log('Content script loaded on Google');
  },
});
```

**代码解析**:
- `matches` 是一个数组,可以包含多个 URL 模式
- `main()` 函数会在匹配的页面加载后自动执行
- WXT 会自动处理 manifest 配置,你只需专注于业务逻辑

### 2.2 匹配多个网站

实际项目中,你的扩展可能需要在多个网站上运行:

```typescript
export default defineContentScript({
  matches: [
    '*://*.google.com/*',   // Google 搜索
    '*://*.bing.com/*',     // Bing 搜索
    '*://*.baidu.com/*',    // 百度搜索
  ],
  
  main() {
    // 可以根据当前网站执行不同逻辑
    const host = window.location.hostname;
    console.log('Content script loaded on:', host);
    
    if (host.includes('google')) {
      // Google 特定逻辑
    } else if (host.includes('baidu')) {
      // 百度特定逻辑
    }
  },
});
```

### 2.3 匹配所有网站

如果你的扩展需要在所有网站上运行(如翻译工具、暗黑模式):

```typescript
export default defineContentScript({
  // <all_urls> 是特殊模式,匹配所有 HTTP/HTTPS 网站
  matches: ['<all_urls>'],
  
  main() {
    console.log('Running on all websites');
  },
});
```

**注意**: 匹配所有网站会增加权限要求,用户安装时会看到"读取所有网站数据"的警告。

---

## 3. URL 匹配模式

匹配模式是内容脚本的核心配置,决定了脚本在哪些页面上运行。

### 3.1 匹配模式语法

URL 匹配模式由三部分组成:

```
<scheme>://<host>/<path>
```

| 组件 | 说明 | 示例 |
|------|------|------|
| **scheme** | 协议部分 | `*`(任意), `http`, `https` |
| **host** | 主机/域名 | `*`(任意), `*.google.com`, `www.example.com` |
| **path** | 路径部分 | `/*`(任意), `/path/*`, `/exact/path` |

### 3.2 常用模式示例

```typescript
export default defineContentScript({
  // 示例1: 所有 HTTPS 网站
  matches: ['https://*/*'],
  
  // 示例2: 特定域名的所有页面(包括子域名)
  // matches: ['*://*.youtube.com/*'],
  
  // 示例3: 特定路径
  // matches: ['*://github.com/*/issues/*'],
  
  // 示例4: 多个不同的模式
  // matches: ['*://*.google.com/*', '*://*.google.co.jp/*'],
  
  main() {},
});
```

**常见模式速查表**:

| 需求 | 模式 |
|------|------|
| 所有网站 | `<all_urls>` |
| 仅 HTTPS | `https://*/*` |
| 特定域名 | `*://example.com/*` |
| 包含子域名 | `*://*.example.com/*` |
| 特定路径 | `*://example.com/path/*` |

### 3.3 排除模式

有时你需要在某个域名的大部分页面运行,但排除特定页面(如登录页):

```typescript
export default defineContentScript({
  matches: ['*://*.example.com/*'],
  
  // excludeMatches: 排除特定页面
  excludeMatches: [
    '*://example.com/login/*',   // 不在登录页运行
    '*://example.com/admin/*',   // 不在管理后台运行
  ],
  
  // includeGlobs/excludeGlobs: 更灵活的 glob 模式
  includeGlobs: ['*://*/article/*'],     // 只在文章页运行
  excludeGlobs: ['*://*/article/private/*'], // 排除私密文章
  
  main() {},
});
```

**matches vs globs 的区别**:
- `matches`: 必须匹配才会注入脚本
- `includeGlobs`: 在 matches 基础上进一步筛选
- `excludeGlobs`: 在已匹配的基础上排除

---

## 4. 运行时机

### 4.1 runAt 选项

`runAt` 控制内容脚本在页面加载的哪个阶段执行:

```typescript
export default defineContentScript({
  matches: ['<all_urls>'],
  
  // 三个可选值:
  // - document_start: DOM 解析前,最早执行
  // - document_end: DOM 解析完成,资源加载中
  // - document_idle: 页面完全加载后 (默认值)
  runAt: 'document_idle',
  
  main() {},
});
```

### 4.2 各时机对比

| 时机 | DOM 状态 | 适用场景 |
|------|----------|----------|
| `document_start` | 未解析,只有 `<html>` | 拦截页面脚本、注入 CSS |
| `document_end` | 已解析,图片/样式加载中 | 操作 DOM 元素 |
| `document_idle` | 完全加载 | 默认选择,最安全稳定 |

### 4.3 document_start 使用示例

在页面脚本执行前拦截某些行为:

```typescript
export default defineContentScript({
  matches: ['<all_urls>'],
  runAt: 'document_start', // 最早执行
  
  main() {
    // 在页面脚本执行前注入代码
    const script = document.createElement('script');
    script.textContent = `
      // 拦截 alert 弹窗
      window.alert = function(msg) {
        console.log('Alert blocked:', msg);
      };
      
      // 拦截 console.log
      const originalLog = console.log;
      console.log = function(...args) {
        originalLog('[LOGGED]', ...args);
      };
    `;
    document.documentElement.appendChild(script);
  },
});
```

**注意**: `document_start` 时 `document.body` 还不存在,只能操作 `document.documentElement`。

---

## 5. 上下文对象 (ContentScriptContext)

### 5.1 上下文的重要性

当用户更新扩展时,旧版本的内容脚本仍在页面中运行,但它无法再与新版本的后台通信。这会导致各种奇怪的 bug。

`ContentScriptContext` 帮助你优雅地处理这种情况:

```typescript
export default defineContentScript({
  matches: ['<all_urls>'],
  
  main(ctx) {
    // ctx.isValid: 当前上下文是否有效
    console.log('Context valid:', ctx.isValid);
    
    // 监听上下文失效(扩展更新时触发)
    ctx.onInvalidated(() => {
      console.log('Extension updated, cleaning up...');
      // 在这里清理定时器、移除 DOM 元素等
    });
  },
});
```

### 5.2 安全的定时器

普通的 `setTimeout`/`setInterval` 在扩展更新后仍会执行,可能导致错误。使用上下文包装的版本:

```typescript
export default defineContentScript({
  matches: ['<all_urls>'],
  
  main(ctx) {
    // 使用 ctx.setTimeout 替代 setTimeout
    // 扩展更新时会自动取消
    ctx.setTimeout(() => {
      if (ctx.isInvalid) return; // 额外检查
      console.log('Safe delayed action');
    }, 5000);
    
    // 使用 ctx.setInterval 替代 setInterval
    const intervalId = ctx.setInterval(() => {
      if (ctx.isInvalid) return;
      console.log('Safe repeated action');
    }, 10000);
    
    // 也可以手动取消
    // clearInterval(intervalId);
  },
});
```

### 5.3 安全的事件监听

```typescript
export default defineContentScript({
  matches: ['<all_urls>'],
  
  main(ctx) {
    // 自动在上下文失效时移除监听器
    ctx.addEventListener(document, 'click', (e) => {
      console.log('Click:', e.target);
    });
    
    ctx.addEventListener(window, 'scroll', () => {
      console.log('Scrolling...');
    });
    
    // 不需要手动 removeEventListener
    // 扩展更新时会自动清理
  },
});
```

---

## 6. DOM 操作

### 6.1 基础操作

内容脚本最常见的用途就是操作页面 DOM:

```typescript
export default defineContentScript({
  matches: ['<all_urls>'],
  
  main() {
    // === 添加元素 ===
    const banner = document.createElement('div');
    banner.id = 'my-extension-banner';
    banner.textContent = 'Extension Active';
    banner.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #4CAF50;
      color: white;
      padding: 10px;
      text-align: center;
      z-index: 999999;
    `;
    document.body.prepend(banner);
    
    // === 修改现有元素 ===
    const title = document.querySelector('h1');
    if (title) {
      title.style.color = 'red';
    }
    
    // === 监听 DOM 变化 ===
    // 对于 SPA 应用,页面内容可能动态变化
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        // 检查新增的节点
        mutation.addedNodes.forEach((node) => {
          if (node instanceof HTMLElement) {
            // 处理新元素...
          }
        });
      });
    });
    
    observer.observe(document.body, {
      childList: true,  // 监听子元素变化
      subtree: true,    // 监听所有后代元素
    });
  },
});
```

### 6.2 等待元素出现

现代 SPA 应用中,元素可能延迟加载。这个工具函数帮你等待元素出现:

```typescript
/**
 * 等待指定选择器的元素出现
 * @param selector CSS 选择器
 * @param timeout 超时时间(毫秒)
 * @returns Promise<Element>
 */
function waitForElement(selector: string, timeout = 10000): Promise<Element> {
  return new Promise((resolve, reject) => {
    // 先检查元素是否已存在
    const element = document.querySelector(selector);
    if (element) {
      resolve(element);
      return;
    }
    
    // 使用 MutationObserver 监听 DOM 变化
    const observer = new MutationObserver(() => {
      const element = document.querySelector(selector);
      if (element) {
        observer.disconnect();
        resolve(element);
      }
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true,
    });
    
    // 超时处理
    setTimeout(() => {
      observer.disconnect();
      reject(new Error(`Element ${selector} not found within ${timeout}ms`));
    }, timeout);
  });
}

// 使用示例
export default defineContentScript({
  matches: ['*://*.youtube.com/*'],
  
  async main() {
    try {
      // 等待 YouTube 视频播放器加载
      const videoPlayer = await waitForElement('#movie_player');
      console.log('Video player found:', videoPlayer);
      
      // 现在可以安全地操作播放器了
    } catch (error) {
      console.log('Video player not found');
    }
  },
});
```

---

## 7. CSS 注入

### 7.1 通过 manifest 注入 (默认)

这是最简单的方式,CSS 会自动注入到匹配的页面:

```typescript
// 导入 CSS 文件
import './style.css';

export default defineContentScript({
  matches: ['<all_urls>'],
  cssInjectionMode: 'manifest', // 默认值,可省略
  
  main() {
    // CSS 已经自动注入
    // 可以直接使用定义的类名
    document.body.classList.add('my-extension-active');
  },
});
```

```css
/* entrypoints/content/style.css */
.my-extension-highlight {
  background-color: yellow !important;
  border: 2px solid red !important;
}

.my-extension-active {
  /* 页面激活时的样式 */
}
```

### 7.2 手动注入

需要动态控制样式时使用:

```typescript
export default defineContentScript({
  matches: ['<all_urls>'],
  cssInjectionMode: 'manual', // 不自动注入
  
  main() {
    // 手动创建并注入样式
    const style = document.createElement('style');
    style.id = 'my-extension-styles';
    style.textContent = `
      .highlight {
        background: yellow;
      }
      
      .hidden {
        display: none !important;
      }
    `;
    document.head.appendChild(style);
    
    // 可以随时修改或移除
    // style.remove();
  },
});
```

### 7.3 UI 模式 (用于 Shadow DOM)

当你使用 Shadow DOM 创建隔离的 UI 时,CSS 只在 Shadow DOM 内生效:

```typescript
import './style.css';

export default defineContentScript({
  matches: ['<all_urls>'],
  cssInjectionMode: 'ui', // CSS 只在 Shadow DOM 内生效
  
  async main(ctx) {
    // 创建 Shadow DOM UI
    const ui = await createShadowRootUi(ctx, {
      name: 'my-ui',
      position: 'inline',
      anchor: 'body',
      onMount(container) {
        // CSS 在这里生效,不会影响页面其他部分
        container.innerHTML = '<div class="highlight">Hello</div>';
      },
    });
    ui.mount();
  },
});
```

---

## 8. 在 iframe 中运行

默认情况下,内容脚本只在顶层页面运行。如果需要在 iframe 中也运行:

```typescript
export default defineContentScript({
  matches: ['<all_urls>'],
  
  allFrames: true,        // 在所有 frame 中运行
  matchAboutBlank: true,  // 匹配 about:blank 页面
  
  main() {
    // 检查当前运行环境
    if (window === window.top) {
      console.log('Running in top frame');
    } else {
      console.log('Running in iframe:', window.location.href);
    }
    
    // 获取 iframe 信息
    if (window.frameElement) {
      console.log('iframe element:', window.frameElement);
    }
  },
});
```

---

## 9. 多个内容脚本

### 9.1 按文件名区分

WXT 支持创建多个内容脚本,只需使用不同的文件名:

```
entrypoints/
├── content.ts           # 通用内容脚本 -> content-scripts/content.js
├── google.content.ts    # Google 专用  -> content-scripts/google.js
├── youtube.content.ts   # YouTube 专用 -> content-scripts/youtube.js
└── github.content.ts    # GitHub 专用  -> content-scripts/github.js
```

每个文件都是独立的内容脚本,有自己的 `matches` 配置。

### 9.2 运行时动态注册

某些场景下,你可能需要在运行时动态决定是否注入脚本:

```typescript
// entrypoints/dynamic.content.ts
export default defineContentScript({
  matches: ['<all_urls>'],
  registration: 'runtime', // 运行时注册,不写入 manifest
  
  main() {
    console.log('Dynamically registered content script');
  },
});
```

通过后台脚本控制注入:

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  // 根据条件动态注册
  async function enableScript() {
    await browser.scripting.registerContentScripts([
      {
        id: 'dynamic-script',
        matches: ['*://*.example.com/*'],
        js: ['content-scripts/dynamic.js'],
      },
    ]);
  }
  
  // 取消注册
  async function disableScript() {
    await browser.scripting.unregisterContentScripts({
      ids: ['dynamic-script'],
    });
  }
});
```

---

## 10. 注入到主世界 (MAIN World)

### 10.1 何时需要主世界?

- 需要访问页面的 JavaScript 变量
- 需要调用页面定义的函数
- 需要拦截/修改页面的原生 API

### 10.2 使用 world 选项

```typescript
export default defineContentScript({
  matches: ['<all_urls>'],
  world: 'MAIN', // 在页面主世界运行
  
  main() {
    // 现在可以访问页面的 JavaScript 变量了!
    console.log('Page variable:', (window as any).somePageVariable);
    
    // 可以调用页面函数
    if (typeof (window as any).pageFunction === 'function') {
      (window as any).pageFunction();
    }
    
    // 可以拦截原生 API
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      console.log('Fetch intercepted:', args[0]);
      return originalFetch.apply(window, args);
    };
  },
});
```

**注意**: 主世界中无法使用 `browser.*` 扩展 API!

### 10.3 通过 injectScript 注入

更灵活的方式是使用 `injectScript`:

```typescript
// entrypoints/injected.ts (unlisted script)
export default defineUnlistedScript(() => {
  console.log('Running in MAIN world');
  
  // 拦截 fetch
  const originalFetch = window.fetch;
  window.fetch = async (...args) => {
    console.log('Fetch:', args);
    return originalFetch.apply(window, args);
  };
});
```

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['<all_urls>'],
  
  async main() {
    // 注入脚本到主世界
    await injectScript('/injected.js', {
      keepInDom: true, // 保留 script 标签
    });
  },
});
```

别忘了配置 `web_accessible_resources`:

```typescript
// wxt.config.ts
export default defineConfig({
  manifest: {
    web_accessible_resources: [
      {
        resources: ['injected.js'],
        matches: ['<all_urls>'],
      },
    ],
  },
});
```

---

## 11. 调试技巧

### 11.1 查看内容脚本日志

1. 打开目标网页
2. 按 F12 打开 DevTools
3. 在 Console 面板查看日志
4. 可以在顶部下拉菜单选择扩展上下文

### 11.2 使用 debugger

```typescript
export default defineContentScript({
  matches: ['<all_urls>'],
  
  main() {
    debugger; // 浏览器会在这里暂停
    console.log('Content script');
  },
});
```

### 11.3 在 Sources 面板找到脚本

DevTools -> Sources -> Content Scripts -> 你的扩展名

---

## 12. 权限配置

```typescript
// wxt.config.ts
export default defineConfig({
  manifest: {
    permissions: [
      'activeTab',     // 当前标签页权限
      'scripting',     // 脚本注入权限(动态注入需要)
    ],
    host_permissions: [
      '*://*.google.com/*',  // 特定网站
      '<all_urls>',          // 所有网站(权限要求高)
    ],
  },
});
```

---

## 13. 小结

| 选项 | 说明 | 默认值 |
|------|------|--------|
| `matches` | URL 匹配模式 | **必填** |
| `excludeMatches` | 排除的 URL | 无 |
| `runAt` | 运行时机 | `document_idle` |
| `allFrames` | 是否在 iframe 运行 | `false` |
| `world` | 执行环境 | `ISOLATED` |
| `cssInjectionMode` | CSS 注入方式 | `manifest` |
| `registration` | 注册方式 | `manifest` |

---

> **下一步**: 学习 [06-消息通信机制](./06-消息通信机制.md),了解内容脚本如何与后台通信
