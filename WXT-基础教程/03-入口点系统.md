# WXT 入口点系统 (Entrypoints)

> **导航**: [上一篇: 项目结构详解](./02-项目结构详解.md) | [下一篇: 后台脚本开发](./04-后台脚本开发.md) | [返回目录](../README.md)

---

## 前言

在上一篇中,我们了解了 WXT 项目的目录结构,知道 `entrypoints/` 是存放入口点的核心目录。但什么是"入口点"?为什么浏览器扩展需要多个入口点?

**入口点 (Entrypoint)** 是浏览器扩展中独立运行的代码单元。一个完整的扩展通常由多个入口点协作完成功能:

- **后台脚本**: 扩展的"大脑",处理核心逻辑,始终在后台运行
- **内容脚本**: 注入到网页中,可以读取和修改页面内容
- **弹出页面**: 点击扩展图标时显示的小窗口
- **选项页面**: 扩展的设置界面

传统开发中,你需要在 `manifest.json` 中手动配置每个入口点的路径、权限、运行条件等。WXT 通过**文件命名约定**自动完成这些配置,让你专注于业务逻辑。

---

## 1. 入口点概述

### 1.1 入口点类型速查表

WXT 根据文件名自动识别入口点类型:

| 类型 | 文件名 | 说明 | 运行环境 |
|------|--------|------|----------|
| Background | `background.ts` | 后台服务 (MV3: Service Worker) | 扩展进程 |
| Content Script | `*.content.ts` | 注入到网页的脚本 | 网页进程(隔离) |
| Popup | `popup.html` | 点击扩展图标的弹出页面 | 扩展进程 |
| Options | `options.html` | 扩展设置页面 | 扩展进程 |
| Side Panel | `sidepanel.html` | 侧边栏面板 (Chrome 114+) | 扩展进程 |
| DevTools | `devtools.html` | 开发者工具面板 | 扩展进程 |
| Sandbox | `sandbox.html` | 沙箱页面,限制权限 | 沙箱进程 |
| Unlisted | 其他 `.ts/.html` | 不在 manifest 中声明 | 按需加载 |

**理解运行环境很重要**:
- **扩展进程**: 可以访问所有扩展 API,如 `browser.storage`、`browser.tabs` 等
- **网页进程(隔离)**: 可以访问页面 DOM,但与页面 JS 隔离,只能访问部分扩展 API
- **沙箱进程**: 完全隔离,无法访问扩展 API,用于运行不信任的代码

---

## 2. Background 入口点

后台脚本是扩展的核心,负责:
- 监听和响应浏览器事件
- 管理扩展的全局状态
- 协调各个组件之间的通信

### 2.1 基础定义

最简单的后台脚本只需要一个函数:

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  console.log('Extension loaded!', { id: browser.runtime.id });
  
  // 监听扩展安装事件
  browser.runtime.onInstalled.addListener((details) => {
    if (details.reason === 'install') {
      console.log('First install');
    } else if (details.reason === 'update') {
      console.log('Updated from', details.previousVersion);
    }
  });
});
```

**代码解析**:
- `defineBackground()` 是 WXT 提供的函数,用于定义后台脚本
- 传入的函数会在扩展启动时执行
- `browser` 是 WXT 自动导入的浏览器扩展 API 对象

### 2.2 配置选项

当需要更多控制时,可以传入配置对象:

```typescript
export default defineBackground({
  // MV2 持久化后台页面,MV3 会忽略此选项
  // 设为 false 可以节省资源,扩展不活动时会被卸载
  persistent: false,
  
  // 输出为 ES Module 格式 (仅 MV3)
  // 启用后支持动态 import() 和代码分割
  type: 'module',
  
  // 仅在指定浏览器构建中包含此入口点
  include: ['chrome', 'firefox'],
  // 或排除特定浏览器
  exclude: ['safari'],
  
  // 主函数,扩展启动时执行
  main() {
    console.log('Background started');
  },
});
```

### 2.3 重要限制: 代码必须在 main 函数内

这是新手最常犯的错误。所有调用浏览器 API 的代码都必须写在 `defineBackground` 的函数内部:

```typescript
// 错误示范: 在 defineBackground 外部调用 API
browser.action.onClicked.addListener(() => {}); // 构建时会报错!

export default defineBackground(() => {
  // 正确: 所有 API 调用都在这里
  browser.action.onClicked.addListener(() => {
    console.log('Clicked!');
  });
});
```

**为什么有这个限制?**

WXT 需要在构建时分析你的代码,确定需要哪些权限、生成正确的 manifest。如果代码在 `defineBackground` 外部,WXT 无法正确分析。

### 2.4 目录形式组织复杂逻辑

当后台脚本变得复杂时,建议拆分成多个文件:

```
entrypoints/
└── background/
    ├── index.ts        # 主入口,导入其他模块
    ├── messaging.ts    # 消息处理逻辑
    ├── alarms.ts       # 定时任务逻辑
    └── storage.ts      # 存储操作逻辑
```

```typescript
// entrypoints/background/index.ts
import './messaging';  // 导入会执行模块中的代码
import './alarms';

export default defineBackground(() => {
  console.log('Background with modules');
});
```

> **深入学习**: 后台脚本的详细开发请参考 [04-后台脚本开发](./04-后台脚本开发.md)

---

## 3. Content Script 入口点

内容脚本是注入到网页中运行的代码,可以:
- 读取和修改页面 DOM
- 监听页面事件
- 与后台脚本通信

### 3.1 基础定义

```typescript
// entrypoints/content.ts
export default defineContentScript({
  // [必需] 指定在哪些网页上运行
  // 使用 Match Pattern 语法
  matches: ['*://*.google.com/*', '*://*.bing.com/*'],
  
  main() {
    console.log('Content script loaded on', window.location.href);
  },
});
```

**Match Pattern 语法说明**:
- `*://` - 匹配 http 和 https
- `*.google.com` - 匹配 google.com 及其所有子域名
- `/*` - 匹配所有路径
- `<all_urls>` - 匹配所有网页(需谨慎使用)

### 3.2 完整配置选项

```typescript
export default defineContentScript({
  // === URL 匹配 ===
  matches: ['<all_urls>'],           // [必需] 运行的网页
  excludeMatches: ['*://*.example.com/*'], // 排除的网页
  includeGlobs: ['*://*/path/*'],    // 额外的 glob 匹配
  excludeGlobs: ['*://*/exclude/*'], // 额外的 glob 排除
  
  // === 运行条件 ===
  allFrames: false,      // 是否在所有 iframe 中运行,默认只在顶层
  matchAboutBlank: false, // 是否匹配 about:blank 页面
  
  // === 运行时机 ===
  runAt: 'document_idle', // 何时注入脚本
  // - 'document_start': DOM 开始构建前,最早时机
  // - 'document_end': DOM 构建完成,但资源可能还在加载
  // - 'document_idle': 页面完全加载后,默认值,最安全
  
  // === 执行环境 ===
  world: 'ISOLATED', // 脚本运行的世界
  // - 'ISOLATED': 隔离环境,有独立的 JS 全局对象,默认值
  // - 'MAIN': 页面主世界,与页面 JS 共享全局对象
  
  // === CSS 注入 ===
  cssInjectionMode: 'manifest', // CSS 如何注入
  // - 'manifest': 通过 manifest 声明,页面加载时就注入
  // - 'manual': 手动控制注入时机
  // - 'ui': 用于 Shadow DOM UI
  
  // === 其他 ===
  registration: 'manifest', // 如何注册脚本
  // - 'manifest': 写入 manifest,始终运行
  // - 'runtime': 运行时动态注册
  
  include: ['chrome'],  // 仅在 Chrome 中包含
  exclude: ['firefox'], // 不在 Firefox 中包含
  
  // 主函数,接收上下文对象
  main(ctx) {
    console.log('Content script context:', ctx);
  },
});
```

### 3.3 命名内容脚本

通过文件名前缀,可以为不同网站创建独立的内容脚本:

```
entrypoints/
├── content.ts           # 通用内容脚本
├── google.content.ts    # 仅在 Google 运行
├── youtube.content.ts   # 仅在 YouTube 运行
└── github.content.ts    # 仅在 GitHub 运行
```

```typescript
// entrypoints/youtube.content.ts
export default defineContentScript({
  matches: ['*://*.youtube.com/*'],
  main() {
    console.log('YouTube specific features');
    // YouTube 专属功能...
  },
});
```

**这样组织的好处**:
- 代码隔离,互不影响
- 只在需要的网站加载,节省资源
- 便于单独维护和调试

### 3.4 内容脚本上下文 (ContentScriptContext)

`main` 函数接收一个上下文对象,提供生命周期管理功能。这在处理扩展更新时特别重要:

```typescript
export default defineContentScript({
  matches: ['<all_urls>'],
  
  main(ctx) {
    // 检查上下文是否已失效(扩展被更新或禁用)
    if (ctx.isInvalid) return;
    
    // 使用上下文包装的定时器
    // 当扩展更新时,这些定时器会自动清理
    ctx.setTimeout(() => {
      console.log('Delayed action');
    }, 1000);
    
    ctx.setInterval(() => {
      console.log('Repeated action');
    }, 5000);
    
    // 使用上下文包装的事件监听
    // 扩展更新时自动移除,避免内存泄漏
    ctx.addEventListener(document, 'click', (e) => {
      console.log('Click:', e.target);
    });
    
    // 监听上下文失效事件
    ctx.onInvalidated(() => {
      console.log('Extension updated, cleaning up...');
      // 执行清理逻辑
    });
  },
});
```

**为什么需要上下文?**

当扩展更新时,旧版本的内容脚本仍在页面中运行,但已经无法与新版本的后台脚本通信。使用上下文可以:
1. 检测这种情况 (`ctx.isInvalid`)
2. 自动清理定时器和事件监听
3. 优雅地停止旧版本的功能

### 3.5 CSS 注入

内容脚本可以注入 CSS 来修改页面样式:

```typescript
// 方式 1: 通过 manifest 自动注入(推荐)
import './style.css';  // 导入 CSS 文件

export default defineContentScript({
  matches: ['<all_urls>'],
  cssInjectionMode: 'manifest', // CSS 会写入 manifest,页面加载时自动注入
  main() {},
});
```

```typescript
// 方式 2: 手动注入(需要动态控制时)
export default defineContentScript({
  matches: ['<all_urls>'],
  cssInjectionMode: 'manual',
  main() {
    // 根据条件决定是否注入
    if (shouldApplyStyles()) {
      const style = document.createElement('style');
      style.textContent = `body { background: #f0f0f0; }`;
      document.head.appendChild(style);
    }
  },
});
```

> **深入学习**: 内容脚本的详细开发请参考 [05-内容脚本开发](./05-内容脚本开发.md)

---

## 4. HTML 入口点 (Popup/Options/Sidepanel)

这些入口点是完整的 HTML 页面,可以使用 React、Vue 等框架构建 UI。

### 4.1 Popup 弹出页面

点击扩展图标时显示的小窗口:

```html
<!-- entrypoints/popup/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- title 会成为 manifest 中的 action.default_title -->
  <title>My Extension</title>
  
  <!-- 通过 meta 标签配置 manifest 选项 -->
  <meta name="manifest.default_icon" content="{
    16: '/icon/16.png',
    32: '/icon/32.png'
  }">
  <!-- browser_action (MV2) 或 page_action -->
  <meta name="manifest.type" content="browser_action">
</head>
<body>
  <div id="app"></div>
  <!-- 引入 React 入口 -->
  <script type="module" src="./main.tsx"></script>
</body>
</html>
```

```typescript
// entrypoints/popup/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './style.css';

ReactDOM.createRoot(document.getElementById('app')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

**Popup 的特点**:
- 点击扩展图标打开,点击外部自动关闭
- 尺寸由内容决定,建议设置固定宽度
- 每次打开都会重新加载,不保持状态

### 4.2 Options 选项页面

扩展的设置界面:

```html
<!-- entrypoints/options/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Extension Options</title>
  
  <!-- 在新标签页打开,而非嵌入式弹窗 -->
  <meta name="manifest.open_in_tab" content="true">
</head>
<body>
  <div id="app"></div>
  <script type="module" src="./main.tsx"></script>
</body>
</html>
```

**Options 的打开方式**:
- `open_in_tab: true` - 在新标签页打开,更大的空间
- `open_in_tab: false` - 在扩展管理页的弹窗中打开

### 4.3 Side Panel 侧边栏

Chrome 114+ 支持的侧边栏面板:

```html
<!-- entrypoints/sidepanel.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Side Panel</title>
</head>
<body>
  <div id="app"></div>
  <script type="module" src="./sidepanel/main.tsx"></script>
</body>
</html>
```

**Side Panel 的优势**:
- 常驻在浏览器侧边,不会被意外关闭
- 可以与当前页面并排显示
- 适合需要持续交互的功能

---

## 5. Unlisted 入口点

不会出现在 manifest 中的脚本或页面,用于特殊场景。

### 5.1 Unlisted 脚本

```typescript
// entrypoints/injected.ts
export default defineUnlistedScript(() => {
  // 这个脚本可以注入到页面的主世界
  // 与页面 JavaScript 共享全局对象
  console.log('Running in page main world');
  
  // 可以访问页面定义的变量和函数
  console.log('Page title:', document.title);
});
```

### 5.2 注入到页面主世界

有时需要访问页面的 JavaScript 变量或拦截页面的函数调用。这需要在页面的"主世界"中运行代码:

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['<all_urls>'],
  
  async main() {
    // 将 unlisted 脚本注入到页面主世界
    await injectScript('/injected.js', {
      keepInDom: true,  // 保留 script 标签
    });
    console.log('Script injected!');
  },
});
```

**需要配置 web_accessible_resources**:

```typescript
// wxt.config.ts
export default defineConfig({
  manifest: {
    web_accessible_resources: [
      {
        resources: ['injected.js'],
        matches: ['<all_urls>'],
      },
    ],
  },
});
```

**主世界 vs 隔离世界**:
- **隔离世界** (默认): 安全,无法被页面 JS 检测或干扰
- **主世界**: 可以与页面 JS 交互,但可能被页面检测到

---

## 6. 入口点文件结构

### 6.1 单文件形式

简单入口点使用单文件:

```
entrypoints/
├── background.ts    # 简单的后台脚本
├── content.ts       # 简单的内容脚本
├── popup.html       # 简单的弹出页面
└── options.html     # 简单的选项页面
```

### 6.2 目录形式

复杂入口点使用目录:

```
entrypoints/
├── background/            # 复杂的后台逻辑
│   ├── index.ts           # 主入口
│   ├── messaging.ts       # 消息处理
│   ├── alarms.ts          # 定时任务
│   └── storage.ts         # 存储操作
├── popup/                 # 完整的 Popup 应用
│   ├── index.html         # HTML 入口
│   ├── main.tsx           # JS 入口
│   ├── App.tsx            # 根组件
│   ├── components/        # 组件目录
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   └── style.css          # 样式
└── youtube.content/       # YouTube 专属内容脚本
    ├── index.ts           # 主入口
    ├── components/
    │   └── Overlay.tsx
    └── style.css
```

**何时使用目录形式**:
- 代码超过 100 行
- 需要多个组件或模块
- 需要独立的样式文件
- 团队协作开发

---

## 7. 常用配置汇总

### 7.1 defineBackground 选项

| 选项 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| persistent | boolean | false | MV2 后台持久化,MV3 忽略 |
| type | 'module' | - | 输出为 ES Module,支持动态导入 |
| include | string[] | - | 仅在这些浏览器中包含 |
| exclude | string[] | - | 在这些浏览器中排除 |

### 7.2 defineContentScript 选项

| 选项 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| matches | string[] | (必需) | URL 匹配模式 |
| excludeMatches | string[] | - | 排除的 URL 模式 |
| allFrames | boolean | false | 是否在所有 iframe 中运行 |
| runAt | string | 'document_idle' | 注入时机 |
| world | string | 'ISOLATED' | 执行环境 |
| cssInjectionMode | string | 'manifest' | CSS 注入方式 |
| registration | string | 'manifest' | 注册方式 |

---

## 8. 小结

**核心概念回顾**:
- 入口点是扩展的独立功能模块,通过文件名自动识别类型
- Background 是核心,处理事件和协调通信
- Content Script 运行在网页中,可以操作 DOM
- HTML 入口点用于构建 UI 页面
- Unlisted 入口点用于特殊场景,如主世界注入

**最佳实践**:
- 复杂入口点使用目录形式组织
- 运行时代码必须在 main 函数内
- 内容脚本使用上下文对象管理生命周期
- 根据需求选择合适的入口点类型

---

## 实战练习

完成本章学习后,建议进行以下练习:

1. 创建一个带有 Popup 和 Background 的基础扩展
2. 为 Google 和 GitHub 创建不同的内容脚本
3. 使用目录形式重构复杂的入口点

> **动手实践**: [03-入口点实战](../WXT-实战练习/03-入口点实战.md)

---

> **导航**: [上一篇: 项目结构详解](./02-项目结构详解.md) | [下一篇: 后台脚本开发](./04-后台脚本开发.md) | [返回目录](../README.md)
