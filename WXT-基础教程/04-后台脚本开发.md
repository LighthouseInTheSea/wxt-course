# 后台脚本开发 (Background Scripts)

> **导航**: [目录](../README.md) | [上一篇: 入口点系统](./03-入口点系统.md) | [下一篇: 内容脚本开发](./05-内容脚本开发.md)
>
> **实战练习**: [后台脚本实战 - 定时提醒插件](../WXT-实战练习/04-后台脚本实战.md)

---

## 1. 后台脚本概述

后台脚本是浏览器扩展的"大脑"，它在后台持续运行（或按需唤醒），负责处理扩展的核心逻辑。与内容脚本不同，后台脚本不与任何特定网页关联，而是作为扩展的中央协调者存在。

**后台脚本的主要职责：**

- **处理扩展事件** - 监听安装、更新、卸载等生命周期事件
- **管理扩展状态** - 维护全局状态，协调各组件间的数据
- **消息中转** - 作为内容脚本、Popup、Options 页面之间的通信枢纽
- **执行定时任务** - 使用 Alarms API 实现周期性任务
- **处理网络请求** - 拦截、修改或阻止网络请求

### 1.1 MV2 vs MV3 的区别

理解 Manifest V2 和 V3 的差异对于开发兼容性良好的扩展至关重要：

| 特性 | Manifest V2 | Manifest V3 |
|------|-------------|-------------|
| 运行方式 | 后台页面 (Background Page) | 服务工作者 (Service Worker) |
| 生命周期 | 可持久化，一直运行 | 按需唤醒，30秒后休眠 |
| DOM 访问 | 有完整 DOM 环境 | 无 DOM，纯 JavaScript |
| 全局状态 | 可持久保存在内存中 | 每次唤醒重置，需持久化 |
| 网络请求 | webRequest API (可阻塞) | declarativeNetRequest (声明式) |

**为什么 Google 推动 MV3？**

1. **性能** - Service Worker 按需运行，节省内存和 CPU
2. **安全** - 声明式 API 减少恶意扩展的攻击面
3. **隐私** - 限制对用户数据的持续访问

**WXT 的价值：** WXT 会自动处理 MV2/MV3 的差异，让你用统一的代码同时支持两种版本。但开发时仍需注意：不要依赖持久化内存状态，始终使用 Storage API 保存重要数据。

---

## 2. 基础后台脚本

### 2.1 最简形式

创建后台脚本非常简单，只需在 `entrypoints/` 目录下创建 `background.ts` 文件：

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  console.log('Background script started');
  
  // 你的后台逻辑写在这里
  // 这个函数会在扩展启动时执行
});
```

**代码解析：**
- `defineBackground` 是 WXT 提供的辅助函数，用于定义后台脚本入口
- 传入的箭头函数会在扩展启动时立即执行
- 所有的事件监听器都应该在这个函数内部注册

### 2.2 对象配置形式

当需要更多配置选项时，可以使用对象形式：

```typescript
// entrypoints/background.ts
export default defineBackground({
  // 是否持久化运行 (仅 MV2 有效)
  // false 表示事件驱动模式，更节省资源
  persistent: false,
  
  // 输出为 ES Module (仅 MV3)
  // 启用后支持动态 import() 和代码分割
  type: 'module',
  
  // 主函数，等同于简写形式的箭头函数
  main() {
    console.log('Background script started');
  },
});
```

**配置选项说明：**

| 选项 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `persistent` | boolean | false | MV2 专用，是否保持后台页面常驻 |
| `type` | 'module' | undefined | MV3 专用，启用 ES 模块支持 |
| `main` | Function | - | 入口函数，扩展启动时执行 |

---

## 3. 扩展生命周期事件

生命周期事件让你能够在扩展的关键时刻执行特定逻辑，比如首次安装时显示欢迎页面，或版本更新时迁移数据。

### 3.1 安装和更新事件

`onInstalled` 是最常用的生命周期事件：

```typescript
export default defineBackground(() => {
  // 监听安装/更新事件
  browser.runtime.onInstalled.addListener((details) => {
    // details.reason 告诉我们触发的原因
    switch (details.reason) {
      case 'install':
        // 首次安装
        console.log('Extension installed');
        
        // 常见操作：打开欢迎页面引导用户
        browser.tabs.create({
          url: browser.runtime.getURL('/welcome.html'),
        });
        
        // 初始化默认设置
        initializeDefaultSettings();
        break;
        
      case 'update':
        // 版本更新
        console.log('Updated from', details.previousVersion);
        
        // 常见操作：数据迁移、显示更新日志
        migrateDataIfNeeded(details.previousVersion);
        break;
        
      case 'browser_update':
        // 浏览器更新（较少使用）
        console.log('Browser updated');
        break;
    }
  });
});

// 初始化默认设置的示例
async function initializeDefaultSettings() {
  const settings = await browser.storage.local.get('settings');
  if (!settings.settings) {
    await browser.storage.local.set({
      settings: {
        theme: 'auto',
        language: 'zh-CN',
        enabled: true,
      }
    });
  }
}
```

**使用场景：**
- `install`: 首次安装，初始化数据、显示欢迎页
- `update`: 版本更新，迁移数据格式、显示新功能介绍
- `browser_update`: 浏览器更新，很少使用

### 3.2 启动事件

每次浏览器启动且扩展已启用时触发：

```typescript
export default defineBackground(() => {
  // 浏览器启动时触发（扩展已启用的情况下）
  browser.runtime.onStartup.addListener(() => {
    console.log('Browser started with extension enabled');
    
    // 常见操作：
    // 1. 清理过期缓存
    cleanExpiredCache();
    
    // 2. 同步远程数据
    syncDataFromServer();
    
    // 3. 重新注册定时任务（MV3 中很重要）
    registerAlarms();
  });
});
```

**注意：** 在 MV3 中，Service Worker 可能随时被终止，`onStartup` 不保证在每次 Service Worker 唤醒时触发。对于需要在每次唤醒时执行的逻辑，应该放在 `defineBackground` 的主函数中。

### 3.3 挂起事件 (MV3 专用)

当 Service Worker 即将休眠时触发，给你最后的机会保存状态：

```typescript
export default defineBackground(() => {
  // Service Worker 即将休眠前触发
  // 注意：这个 API 可能不存在于所有浏览器
  browser.runtime.onSuspend?.addListener(() => {
    console.log('Service worker suspending, save state...');
    
    // 紧急保存内存中的状态
    saveInMemoryState();
    
    // 注意：这里只有很短的时间执行，避免异步操作
  });
});
```

**最佳实践：** 不要依赖 `onSuspend`，而是在状态变化时就立即持久化。把 `onSuspend` 作为最后的保障。

---

## 4. 扩展图标点击

### 4.1 无 Popup 时响应点击

如果你的扩展不需要 Popup 弹窗，可以直接响应图标点击事件：

```typescript
// wxt.config.ts - 配置空的 action，不设置 popup
export default defineConfig({
  manifest: {
    action: {}, // 空对象表示有图标但无弹窗
  },
});
```

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  // 监听图标点击
  browser.action.onClicked.addListener(async (tab) => {
    console.log('Extension icon clicked on tab:', tab.id);
    
    // 示例1：切换侧边栏
    await browser.sidePanel.open({ tabId: tab.id });
    
    // 示例2：向当前页面注入脚本
    await browser.scripting.executeScript({
      target: { tabId: tab.id! },
      func: () => {
        // 这个函数会在网页中执行
        alert('Hello from extension!');
      },
    });
    
    // 示例3：切换扩展功能开关
    await toggleExtensionFeature(tab.id);
  });
});
```

### 4.2 MV2/MV3 兼容写法

由于 MV2 使用 `browserAction`，MV3 使用 `action`，需要做兼容处理：

```typescript
export default defineBackground(() => {
  // 兼容 MV2 (browserAction) 和 MV3 (action)
  // 使用空值合并运算符选择可用的 API
  const action = browser.action ?? browser.browserAction;
  
  action.onClicked.addListener((tab) => {
    console.log('Clicked on', tab.url);
  });
  
  // 动态设置图标徽章
  action.setBadgeText({ text: '99+' });
  action.setBadgeBackgroundColor({ color: '#FF0000' });
});
```

---

## 5. 定时任务 (Alarms)

Alarms API 是在 MV3 中执行定时任务的推荐方式。与 `setInterval` 不同，Alarms 会在 Service Worker 休眠后仍然触发，并唤醒 Service Worker 执行任务。

### 5.1 创建定时器

```typescript
export default defineBackground(() => {
  // 在扩展启动时创建定时任务
  // 注意：如果定时器已存在，不会重复创建
  browser.alarms.create('checkUpdates', {
    delayInMinutes: 1,      // 首次触发延迟（分钟）
    periodInMinutes: 30,    // 重复间隔（分钟）
  });
  
  // 创建一次性定时器（不设置 periodInMinutes）
  browser.alarms.create('oneTimeTask', {
    delayInMinutes: 5,      // 5分钟后触发一次
  });
  
  // 使用时间戳创建（更精确）
  browser.alarms.create('scheduledTask', {
    when: Date.now() + 60000,  // 1分钟后触发
  });
  
  // 监听定时器触发
  browser.alarms.onAlarm.addListener((alarm) => {
    console.log('Alarm triggered:', alarm.name);
    
    switch (alarm.name) {
      case 'checkUpdates':
        checkForUpdates();
        break;
      case 'oneTimeTask':
        executeOneTimeTask();
        break;
    }
  });
});

async function checkForUpdates() {
  console.log('Checking for updates at', new Date().toISOString());
  // 执行更新检查逻辑
}
```

**重要限制：**
- 最小间隔为 1 分钟（`periodInMinutes >= 1`）
- 定时器名称必须唯一
- MV3 中定时器触发会唤醒 Service Worker

### 5.2 管理定时器

```typescript
// 获取所有已创建的定时器
const alarms = await browser.alarms.getAll();
console.log('Active alarms:', alarms);

// 获取特定定时器的信息
const alarm = await browser.alarms.get('checkUpdates');
if (alarm) {
  console.log('Next trigger at:', new Date(alarm.scheduledTime));
}

// 清除特定定时器
await browser.alarms.clear('checkUpdates');

// 清除所有定时器
await browser.alarms.clearAll();
```

---

## 6. 右键菜单 (Context Menus)

右键菜单让用户可以在特定上下文中快速访问扩展功能。

### 6.1 创建菜单

```typescript
export default defineBackground(() => {
  // 重要：在 onInstalled 中创建菜单，避免重复创建
  browser.runtime.onInstalled.addListener(() => {
    // 创建父菜单
    browser.contextMenus.create({
      id: 'parent-menu',
      title: 'My Extension',           // 显示的文字
      contexts: ['selection', 'page'], // 显示时机
    });
    
    // 创建子菜单 - 翻译选中文本
    browser.contextMenus.create({
      id: 'translate',
      parentId: 'parent-menu',       // 指定父菜单
      title: 'Translate "%s"',       // %s 会被替换为选中的文本
      contexts: ['selection'],       // 仅在选中文本时显示
    });
    
    // 创建子菜单 - 保存页面
    browser.contextMenus.create({
      id: 'save-page',
      parentId: 'parent-menu',
      title: 'Save Page',
      contexts: ['page'],            // 在页面空白处右键时显示
    });
    
    // 分隔线
    browser.contextMenus.create({
      id: 'separator',
      parentId: 'parent-menu',
      type: 'separator',
      contexts: ['all'],
    });
    
    // 带图标的菜单项（需要 Chrome 128+）
    browser.contextMenus.create({
      id: 'with-icon',
      title: 'Settings',
      contexts: ['action'],          // 在扩展图标上右键
    });
  });
  
  // 监听菜单点击
  browser.contextMenus.onClicked.addListener((info, tab) => {
    // info 包含点击信息，tab 是当前标签页
    switch (info.menuItemId) {
      case 'translate':
        translateText(info.selectionText!);
        break;
      case 'save-page':
        savePage(tab!);
        break;
    }
  });
});

function translateText(text: string) {
  console.log('Translating:', text);
  // 调用翻译 API
}

function savePage(tab: browser.Tabs.Tab) {
  console.log('Saving page:', tab.url);
  // 保存页面逻辑
}
```

**contexts 可选值：**

| 值 | 说明 |
|---|------|
| `page` | 页面空白处 |
| `selection` | 选中文本时 |
| `link` | 链接上 |
| `image` | 图片上 |
| `video` | 视频上 |
| `audio` | 音频上 |
| `frame` | iframe 中 |
| `editable` | 可编辑元素中 |
| `action` | 扩展图标上 |
| `all` | 所有情况 |

### 6.2 动态更新菜单

```typescript
// 更新菜单文字或属性
await browser.contextMenus.update('translate', {
  title: 'Translate to Chinese',
  enabled: true,  // 是否可点击
});

// 删除特定菜单
await browser.contextMenus.remove('translate');

// 删除所有菜单
await browser.contextMenus.removeAll();
```

---

## 7. 快捷键 (Commands)

快捷键让用户可以通过键盘快速触发扩展功能。

### 7.1 配置快捷键

在 `wxt.config.ts` 中声明快捷键：

```typescript
// wxt.config.ts
export default defineConfig({
  manifest: {
    commands: {
      // 自定义命令
      'toggle-feature': {
        suggested_key: {
          default: 'Ctrl+Shift+Y',
          mac: 'Command+Shift+Y',
          linux: 'Ctrl+Shift+Y',
        },
        description: 'Toggle feature on/off',
      },
      
      // 另一个命令
      'quick-translate': {
        suggested_key: {
          default: 'Alt+T',
        },
        description: 'Translate selected text',
      },
      
      // 特殊命令：打开 Popup（名称必须是 _execute_action）
      '_execute_action': {
        suggested_key: {
          default: 'Alt+Shift+P',
        },
        description: 'Open extension popup',
      },
    },
  },
});
```

**注意事项：**
- 快捷键可能与浏览器或其他扩展冲突
- 用户可以在 `chrome://extensions/shortcuts` 自定义
- 使用 `suggested_key` 表示这是建议值，不是强制的

### 7.2 监听快捷键

```typescript
export default defineBackground(() => {
  browser.commands.onCommand.addListener((command, tab) => {
    console.log('Command triggered:', command);
    
    switch (command) {
      case 'toggle-feature':
        toggleFeature();
        break;
      case 'quick-translate':
        quickTranslate(tab);
        break;
      // _execute_action 会自动打开 Popup，无需处理
    }
  });
});

async function toggleFeature() {
  // 切换功能状态
  const { enabled } = await browser.storage.local.get('enabled');
  await browser.storage.local.set({ enabled: !enabled });
  
  // 更新图标状态
  const action = browser.action ?? browser.browserAction;
  action.setBadgeText({ text: enabled ? '' : 'ON' });
}
```

---

## 8. 网络请求处理

### 8.1 使用 declarativeNetRequest (MV3 推荐)

MV3 使用声明式的网络请求 API，比 webRequest 更安全、更高效：

```typescript
// wxt.config.ts
export default defineConfig({
  manifest: {
    permissions: ['declarativeNetRequest'],
    declarative_net_request: {
      rule_resources: [
        {
          id: 'ruleset_1',
          enabled: true,
          path: 'rules.json',  // 规则文件路径
        },
      ],
    },
  },
});
```

创建规则文件 `public/rules.json`：

```json
[
  {
    "id": 1,
    "priority": 1,
    "action": { "type": "block" },
    "condition": {
      "urlFilter": "*://ads.example.com/*",
      "resourceTypes": ["script", "image", "xmlhttprequest"]
    }
  },
  {
    "id": 2,
    "priority": 1,
    "action": {
      "type": "redirect",
      "redirect": { "url": "https://example.com/blocked.html" }
    },
    "condition": {
      "urlFilter": "*://malware.com/*",
      "resourceTypes": ["main_frame"]
    }
  },
  {
    "id": 3,
    "priority": 1,
    "action": {
      "type": "modifyHeaders",
      "requestHeaders": [
        { "header": "Cookie", "operation": "remove" }
      ]
    },
    "condition": {
      "urlFilter": "*://tracking.com/*"
    }
  }
]
```

### 8.2 动态规则

运行时动态添加/删除规则：

```typescript
export default defineBackground(() => {
  // 添加动态规则
  browser.declarativeNetRequest.updateDynamicRules({
    addRules: [
      {
        id: 100,
        priority: 1,
        action: { type: 'block' },
        condition: {
          urlFilter: '*://blocked.com/*',
          resourceTypes: ['main_frame', 'sub_frame'],
        },
      },
    ],
    removeRuleIds: [], // 要删除的规则 ID
  });
  
  // 获取当前动态规则
  browser.declarativeNetRequest.getDynamicRules().then(rules => {
    console.log('Dynamic rules:', rules);
  });
});
```

---

## 9. 状态管理

### 9.1 MV3 状态持久化挑战

MV3 的 Service Worker 会在闲置 30 秒后休眠，内存中的状态会丢失。因此必须使用持久化存储：

```typescript
import { storage } from 'wxt/storage';

// 定义类型安全的存储项
const counterItem = storage.defineItem<number>('local:counter', {
  fallback: 0,  // 默认值
});

const settingsItem = storage.defineItem<{
  enabled: boolean;
  theme: 'light' | 'dark';
}>('local:settings', {
  fallback: { enabled: true, theme: 'light' },
});

export default defineBackground(() => {
  browser.action.onClicked.addListener(async () => {
    // 读取当前值
    const current = await counterItem.getValue();
    
    // 更新值（立即持久化）
    await counterItem.setValue(current + 1);
    
    console.log('Counter:', current + 1);
  });
  
  // 监听存储变化
  settingsItem.watch((newValue, oldValue) => {
    console.log('Settings changed:', oldValue, '->', newValue);
  });
});
```

### 9.2 保持 Service Worker 活跃（谨慎使用）

某些特殊场景（如长时间的 WebSocket 连接）需要保持 Service Worker 活跃：

```typescript
export default defineBackground(() => {
  // 方法1：定时心跳（不推荐，浪费资源）
  setInterval(() => {
    console.log('Keeping alive...');
  }, 25000);  // 每 25 秒，防止 30 秒超时
  
  // 方法2：使用 Alarms（更优雅）
  browser.alarms.create('keepalive', { periodInMinutes: 0.5 });
  browser.alarms.onAlarm.addListener((alarm) => {
    if (alarm.name === 'keepalive') {
      // 什么都不做，只是保持活跃
    }
  });
});
```

**警告：** 保持 Service Worker 活跃会消耗用户资源，应该只在绝对必要时使用。大多数场景都可以通过合理设计来避免。

---

## 10. 模块化组织

当后台脚本逻辑复杂时，应该拆分成多个模块。

### 10.1 目录结构

```
entrypoints/
└── background/
    ├── index.ts        # 主入口，导入其他模块
    ├── alarms.ts       # 定时任务相关
    ├── commands.ts     # 快捷键处理
    ├── contextMenus.ts # 右键菜单
    ├── messaging.ts    # 消息处理
    └── storage.ts      # 存储管理
```

### 10.2 模块导入

```typescript
// entrypoints/background/index.ts
// 导入所有子模块（它们的副作用会自动执行）
import './alarms';
import './commands';
import './contextMenus';
import './messaging';

export default defineBackground(() => {
  console.log('Background modules loaded');
  
  // 主入口的初始化逻辑
});
```

```typescript
// entrypoints/background/alarms.ts
// 模块化的定时任务

// 注册定时器
browser.alarms.create('sync', { periodInMinutes: 15 });
browser.alarms.create('cleanup', { periodInMinutes: 60 });

// 处理定时器
browser.alarms.onAlarm.addListener((alarm) => {
  switch (alarm.name) {
    case 'sync':
      syncData();
      break;
    case 'cleanup':
      cleanupCache();
      break;
  }
});

async function syncData() {
  console.log('Syncing data...');
  // 同步逻辑
}

async function cleanupCache() {
  console.log('Cleaning up cache...');
  // 清理逻辑
}
```

```typescript
// entrypoints/background/messaging.ts
// 模块化的消息处理

import { onMessage, sendMessage } from 'webext-bridge/background';

// 处理来自 Content Script 的翻译请求
onMessage('translate', async ({ data }) => {
  const result = await translateText(data.text, data.targetLang);
  return { translation: result };
});

// 处理设置更新
onMessage('updateSettings', async ({ data }) => {
  await browser.storage.local.set({ settings: data });
  return { success: true };
});
```

---

## 11. 调试技巧

### 11.1 查看后台日志

**Chrome:**
1. 打开 `chrome://extensions`
2. 确保开启"开发者模式"
3. 找到你的扩展
4. 点击 "Service Worker" 或 "背景页" 链接
5. 在弹出的 DevTools 中查看 Console

**Firefox:**
1. 打开 `about:debugging#/runtime/this-firefox`
2. 找到你的扩展
3. 点击 "检查" 按钮

### 11.2 常见调试方法

```typescript
export default defineBackground(() => {
  // 1. 打印扩展信息
  console.log('=== Extension Debug Info ===');
  console.log('Extension ID:', browser.runtime.id);
  console.log('Manifest:', browser.runtime.getManifest());
  console.log('Started at:', new Date().toISOString());
  
  // 2. 监控 Service Worker 生命周期（MV3）
  console.log('Service Worker is running');
  
  // 3. 错误追踪
  try {
    riskyOperation();
  } catch (error) {
    console.error('Operation failed:', error);
    // 可以发送到错误追踪服务
  }
  
  // 4. 性能计时
  console.time('initialization');
  initializeExtension();
  console.timeEnd('initialization');
  
  // 5. 全局错误捕获
  self.addEventListener('error', (event) => {
    console.error('Uncaught error:', event.error);
  });
  
  self.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
  });
});
```

---

## 12. 权限配置

后台脚本常用的权限：

```typescript
// wxt.config.ts
export default defineConfig({
  manifest: {
    permissions: [
      'alarms',           // 定时任务
      'contextMenus',     // 右键菜单
      'storage',          // 本地存储
      'tabs',             // 标签页操作
      'scripting',        // 脚本注入（MV3）
      'activeTab',        // 当前活动标签页
      'notifications',    // 系统通知
      'webRequest',       // 网络请求监听（MV2）
      'declarativeNetRequest', // 声明式网络请求（MV3）
    ],
    
    // 可选权限（用户点击时才请求）
    optional_permissions: [
      'history',
      'bookmarks',
    ],
    
    // 主机权限
    host_permissions: [
      '<all_urls>',                    // 所有网站
      // 或指定特定网站
      'https://*.example.com/*',
      'https://api.myservice.com/*',
    ],
  },
});
```

---

## 13. 小结

| 功能 | API | 所需权限 |
|------|-----|---------|
| 生命周期事件 | `browser.runtime.onInstalled` | 无 |
| 图标点击 | `browser.action.onClicked` | 无 |
| 定时任务 | `browser.alarms` | `alarms` |
| 右键菜单 | `browser.contextMenus` | `contextMenus` |
| 快捷键 | `browser.commands` | 无 |
| 网络请求 | `browser.declarativeNetRequest` | `declarativeNetRequest` |
| 通知 | `browser.notifications` | `notifications` |
| 存储 | `browser.storage` | `storage` |

**关键要点：**
1. **MV3 兼容性** - 不要依赖内存状态，使用 Storage API 持久化
2. **事件驱动** - 在 `defineBackground` 内注册所有事件监听器
3. **模块化** - 复杂逻辑拆分成独立模块
4. **权限最小化** - 只申请必需的权限

---

> **下一步**: 学习 [内容脚本开发](./05-内容脚本开发.md)，了解如何在网页中注入和运行代码。
