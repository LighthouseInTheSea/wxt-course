# WXT 项目结构详解

> **导航**: [上一篇: WXT简介与环境搭建](./01-WXT简介与环境搭建.md) | [下一篇: 入口点系统](./03-入口点系统.md) | [返回目录](../README.md)

---

## 前言

在上一篇教程中,我们成功创建了第一个 WXT 项目。现在你可能会好奇:这些文件夹都是做什么用的?为什么要这样组织代码?

本篇将深入讲解 WXT 的项目结构设计理念,帮助你理解每个目录的作用,以及如何根据项目规模灵活调整结构。掌握这些知识后,你将能够更高效地组织自己的扩展代码。

---

## 1. 标准目录结构

WXT 采用"约定优于配置"的设计理念。这意味着只要你按照约定的方式组织文件,WXT 就能自动识别并正确处理它们,无需额外配置。

```
my-extension/
├── .wxt/                    # [自动生成] WXT 运行时文件
│   ├── tsconfig.json        # TypeScript 配置
│   ├── wxt.d.ts             # 类型定义
│   └── types/               # 自动导入类型
├── .output/                 # [自动生成] 构建输出目录
│   ├── chrome-mv3/          # Chrome MV3 构建产物
│   └── firefox-mv2/         # Firefox MV2 构建产物
├── entrypoints/             # [必需] 扩展入口点
├── public/                  # [可选] 静态资源
├── components/              # [可选] 共享组件
├── composables/             # [可选] 组合式函数
├── hooks/                   # [可选] React Hooks
├── utils/                   # [可选] 工具函数
├── assets/                  # [可选] 需要处理的资源
├── modules/                 # [可选] WXT 模块
├── wxt.config.ts            # WXT 配置文件
├── package.json
└── tsconfig.json
```

**理解要点**:
- 带 `[自动生成]` 标记的目录由 WXT 自动创建和管理,你不需要手动修改
- 带 `[必需]` 标记的目录是项目运行的基础,必须存在
- 带 `[可选]` 标记的目录可以根据项目需要自由添加

---

## 2. 核心目录详解

### 2.1 entrypoints 目录 - 扩展的"入口大门"

这是 WXT 最核心的目录。浏览器扩展由多个独立的"入口点"组成,比如后台脚本、弹出页面、内容脚本等。WXT 通过文件名自动识别入口点类型。

```
entrypoints/
├── background.ts            # 后台服务工作者
├── popup/                   # 弹出页面 (目录形式)
│   ├── index.html
│   ├── main.tsx
│   ├── App.tsx
│   └── style.css
├── popup.html               # 弹出页面 (单文件形式)
├── options.html             # 选项页面
├── content.ts               # 内容脚本
├── google.content.ts        # 特定网站的内容脚本
├── injected.ts              # 注入到页面的脚本
└── devtools.html            # 开发者工具面板
```

**为什么这样设计?**

传统的扩展开发需要在 `manifest.json` 中手动配置每个入口点的路径,容易出错且难以维护。WXT 通过文件命名约定自动生成配置,让你专注于代码逻辑。

#### 入口点命名规则速查表

| 文件名模式 | 类型 | 说明 |
|-----------|------|------|
| `background.ts` | 后台脚本 | 扩展的"大脑",处理核心逻辑 |
| `popup.html` 或 `popup/index.html` | 弹出页面 | 点击扩展图标显示的界面 |
| `options.html` 或 `options/index.html` | 选项页面 | 扩展设置页面 |
| `content.ts` | 内容脚本 | 注入到网页中运行的脚本 |
| `[name].content.ts` | 命名内容脚本 | 针对特定网站的内容脚本 |
| `sidepanel.html` | 侧边栏面板 | Chrome 114+ 的侧边栏功能 |
| `devtools.html` | 开发者工具 | 开发者工具中的自定义面板 |
| `sandbox.html` | 沙箱页面 | 隔离环境中运行的页面 |

> **深入学习**: 入口点的详细配置请参考 [03-入口点系统](./03-入口点系统.md)

---

### 2.2 public 目录 - 静态资源仓库

存放不需要经过构建工具处理的静态文件。这些文件会被原样复制到输出目录,路径保持不变。

```
public/
├── icon/
│   ├── 16.png               # 工具栏图标
│   ├── 32.png               # Windows 图标
│   ├── 48.png               # 扩展管理页图标
│   └── 128.png              # Chrome 应用商店图标
├── _locales/                # 国际化文件
│   ├── en/
│   │   └── messages.json
│   └── zh_CN/
│       └── messages.json
└── images/
    └── logo.svg
```

**什么时候用 public?**
- 扩展图标(必须使用固定路径)
- 国际化语言文件(`_locales` 目录)
- 不需要打包处理的图片、字体
- 需要通过固定 URL 访问的资源

**访问方式**:
```typescript
// 在代码中获取 public 目录下的资源 URL
const iconUrl = browser.runtime.getURL('/icon/128.png');
```

---

### 2.3 assets 目录 - 需要处理的资源

与 `public` 不同,`assets` 目录下的文件会经过 Vite 构建工具处理。这意味着:
- 图片可以被压缩优化
- CSS 可以使用预处理器(Sass、Less 等)
- 可以使用 `import` 语句引入

```
assets/
├── styles/
│   └── global.css
├── fonts/
│   └── custom.woff2
└── images/
    └── background.png
```

**使用示例**:
```typescript
// 导入图片,Vite 会处理并返回最终 URL
import logo from '~/assets/images/logo.png';

// 导入并应用全局样式
import '~/assets/styles/global.css';
```

**public vs assets 对比**:

| 特性 | public | assets |
|------|--------|--------|
| 构建处理 | 原样复制 | 经过优化 |
| 引用方式 | runtime.getURL | import 语句 |
| 文件名 | 保持不变 | 可能添加哈希 |
| 适用场景 | 图标、_locales | 组件内资源 |

---

### 2.4 .wxt 目录 - 自动生成的配置

WXT 在这个目录中自动生成必要的配置文件:

- **tsconfig.json**: 预配置的 TypeScript 设置,包含路径别名等
- **wxt.d.ts**: 全局类型定义,如 `defineBackground`、`defineContentScript` 等
- **types/imports.d.ts**: 自动导入功能的类型声明

**重要提醒**: 
1. 此目录应添加到 `.gitignore`,不要提交到版本控制
2. 运行 `pnpm wxt prepare` 可以手动重新生成这些文件
3. 如果类型提示失效,通常重新生成即可解决

---

### 2.5 .output 目录 - 构建产物

这里存放最终的扩展文件,可以直接加载到浏览器中测试:

```
.output/
├── chrome-mv3/              # Chrome Manifest V3 版本
│   ├── manifest.json        # 自动生成的清单文件
│   ├── background.js
│   ├── popup.html
│   ├── popup.js
│   └── content-scripts/
│       └── content.js
├── chrome-mv3.zip           # 打包后的 ZIP 文件
├── firefox-mv2/             # Firefox Manifest V2 版本
└── firefox-mv2.zip
```

**加载扩展进行测试**:
1. Chrome: 打开 `chrome://extensions`,开启"开发者模式",点击"加载已解压的扩展程序",选择 `.output/chrome-mv3` 目录
2. Firefox: 打开 `about:debugging`,点击"此 Firefox",点击"临时载入附加组件",选择 `.output/firefox-mv2/manifest.json`

---

## 3. 目录路径自定义

### 3.1 配置示例

如果你不喜欢默认的目录结构,可以在 `wxt.config.ts` 中自定义:

```typescript
import { defineConfig } from 'wxt';

export default defineConfig({
  // 这些路径相对于项目根目录
  srcDir: 'src',              // 源码目录,默认: '.'
  modulesDir: 'wxt-modules',  // WXT 模块目录,默认: 'modules'
  outDir: 'dist',             // 输出目录,默认: '.output'
  publicDir: 'static',        // 静态资源目录,默认: 'public'
  
  // 这个路径相对于 srcDir
  entrypointsDir: 'entries',  // 入口点目录,默认: 'entrypoints'
});
```

### 3.2 使用 src 目录(推荐)

许多开发者习惯将源码放在 `src` 目录下,使项目根目录更整洁:

```typescript
// wxt.config.ts
export default defineConfig({
  srcDir: 'src',
});
```

启用后的目录结构变为:

```
my-extension/
├── src/                     # 所有源码都在这里
│   ├── entrypoints/
│   ├── components/
│   ├── assets/
│   └── public/
├── wxt.config.ts            # 配置文件保持在根目录
├── package.json
└── tsconfig.json
```

**这样做的好处**:
- 源码与配置文件分离,结构更清晰
- 符合大多数前端项目的习惯
- 便于配置编辑器和工具

---

## 4. 路径别名

WXT 默认配置了 `~` 和 `@` 两个路径别名,都指向 `srcDir` 目录:

```typescript
// 使用别名导入,避免相对路径地狱
import { storage } from '~/utils/storage';      // 推荐用 ~
import Button from '~/components/Button';
import { useAuth } from '@/hooks/useAuth';      // @ 也可以
```

**为什么要用路径别名?**

没有别名时,深层嵌套的文件需要写很长的相对路径:
```typescript
// 痛苦的相对路径
import { storage } from '../../../utils/storage';
```

使用别名后,无论文件在哪个层级,路径都是一样的:
```typescript
// 清爽的别名路径
import { storage } from '~/utils/storage';
```

### 4.1 自定义别名

可以添加更多的别名来组织代码:

```typescript
// wxt.config.ts
export default defineConfig({
  alias: {
    '@components': './src/components',
    '@utils': './src/utils',
    '@hooks': './src/hooks',
    '@services': './src/services',
  },
});
```

---

## 5. 输出目录结构模板

你可以自定义输出目录的命名模式,这在需要同时构建多个版本时很有用:

```typescript
export default defineConfig({
  outDirTemplate: '{{browser}}-mv{{manifestVersion}}{{modeSuffix}}',
});
```

**可用的模板变量**:

| 变量 | 说明 | 示例值 |
|------|------|--------|
| `{{browser}}` | 目标浏览器 | chrome, firefox, edge |
| `{{manifestVersion}}` | Manifest 版本 | 2 或 3 |
| `{{mode}}` | 构建模式 | development, production |
| `{{modeSuffix}}` | 模式后缀 | -dev 或 空 |
| `{{command}}` | 命令 | build 或 serve |

**示例输出目录名**:
- 开发模式: `chrome-mv3-dev`
- 生产模式: `chrome-mv3`
- Firefox: `firefox-mv2`

---

## 6. 文件组织最佳实践

### 6.1 按功能模块组织(推荐)

对于中大型项目,建议按功能模块组织代码,每个功能模块包含自己的组件、hooks 和工具函数:

```
src/
├── entrypoints/             # 入口点(保持扁平)
├── features/                # 功能模块
│   ├── translation/         # 翻译功能
│   │   ├── components/      # 翻译相关组件
│   │   ├── hooks/           # 翻译相关 hooks
│   │   ├── utils/           # 翻译工具函数
│   │   └── index.ts         # 模块导出
│   └── settings/            # 设置功能
│       ├── components/
│       ├── hooks/
│       └── index.ts
├── shared/                  # 跨功能共享
│   ├── components/          # 通用组件(Button、Modal等)
│   ├── hooks/               # 通用 hooks
│   └── utils/               # 通用工具
└── types/                   # 类型定义
```

**这种组织方式的优势**:
- 相关代码放在一起,便于理解和维护
- 功能模块可以独立开发和测试
- 减少跨目录的引用,依赖关系清晰

### 6.2 入口点目录组织

对于复杂的入口点(如 popup),建议使用目录形式而非单文件:

```
entrypoints/
├── popup/                   # 目录形式的 popup
│   ├── index.html           # HTML 入口
│   ├── main.tsx             # JS 入口,挂载 React
│   ├── App.tsx              # 根组件
│   ├── components/          # popup 专用组件
│   │   ├── Header.tsx
│   │   └── Footer.tsx
│   └── style.css            # 样式文件
├── background/              # 目录形式的 background
│   ├── index.ts             # 主入口
│   ├── alarms.ts            # 定时任务处理
│   ├── messaging.ts         # 消息处理
│   └── storage.ts           # 存储操作
└── youtube.content/         # 针对 YouTube 的内容脚本
    ├── index.ts             # 主入口
    ├── App.tsx              # UI 组件
    └── style.css            # 样式
```

**何时使用目录形式**:
- 入口点代码超过 100 行
- 需要拆分成多个子模块
- 包含多个组件或样式文件

---

## 7. 忽略文件配置

### 7.1 .gitignore 推荐配置

```gitignore
# WXT 生成文件(必须忽略)
.wxt/
.output/
*.crx
*.xpi
*.zip

# 依赖
node_modules/

# 编辑器配置
.vscode/
.idea/

# 系统文件
.DS_Store
Thumbs.db

# 日志
*.log

# 环境变量(包含敏感信息)
.env.local
```

### 7.2 .wxtignore 文件

类似 `.gitignore`,可以让 WXT 忽略特定的入口点文件。这在开发调试时很有用:

```
# 忽略测试用的入口点
test.content.ts
debug.html

# 忽略未完成的功能
wip-feature.content.ts
```

---

## 8. 环境变量

### 8.1 .env 文件支持

WXT 基于 Vite,完全支持 `.env` 文件:

```
.env                  # 所有环境加载
.env.local            # 本地覆盖,不提交到 git
.env.development      # 仅开发环境加载
.env.production       # 仅生产环境加载
```

**加载优先级**(后者覆盖前者):
`.env` -> `.env.local` -> `.env.[mode]` -> `.env.[mode].local`

### 8.2 使用环境变量

```bash
# .env
VITE_API_URL=https://api.example.com
VITE_DEBUG=true
WXT_SECRET_KEY=abc123  # 不会暴露给客户端
```

```typescript
// 在代码中使用
const apiUrl = import.meta.env.VITE_API_URL;
const isDebug = import.meta.env.VITE_DEBUG === 'true';

// 检查当前环境
if (import.meta.env.DEV) {
  console.log('开发模式');
}
```

**安全提醒**: 
- 只有 `VITE_` 前缀的变量会暴露给客户端代码
- 不要在 `VITE_` 变量中存放敏感信息(API 密钥等)
- `.env.local` 应该添加到 `.gitignore`

---

## 9. 小结

| 目录 | 用途 | 是否必需 | 是否提交 Git |
|------|------|----------|--------------|
| entrypoints/ | 扩展入口点 | 是 | 是 |
| public/ | 静态资源 | 否 | 是 |
| assets/ | 需处理资源 | 否 | 是 |
| components/ | 共享组件 | 否 | 是 |
| utils/ | 工具函数 | 否 | 是 |
| .wxt/ | 生成配置 | 自动 | 否 |
| .output/ | 构建产物 | 自动 | 否 |

**关键要点回顾**:
1. `entrypoints/` 是核心,通过文件名约定自动识别入口点类型
2. `public/` 存放原样复制的资源,`assets/` 存放需要构建处理的资源
3. 使用 `srcDir: 'src'` 配置可以让项目结构更整洁
4. 路径别名 `~` 和 `@` 帮助避免相对路径地狱
5. 中大型项目建议按功能模块组织代码

---

## 实战练习

完成本章学习后,建议进行以下练习:

1. **调整项目结构**: 将现有项目改为使用 `src` 目录
2. **创建别名**: 添加 `@components`、`@utils` 等自定义别名
3. **组织入口点**: 将 popup 改为目录形式,拆分成多个文件

> **动手实践**: [02-项目结构实战](../WXT-实战练习/02-项目结构实战.md)

---

> **导航**: [上一篇: WXT简介与环境搭建](./01-WXT简介与环境搭建.md) | [下一篇: 入口点系统](./03-入口点系统.md) | [返回目录](../README.md)
