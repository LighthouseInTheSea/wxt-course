# WXT 实战练习 06: 消息通信机制

## 练习目标

通过本练习,你将:
- 掌握扩展各部分之间的通信
- 实现请求-响应模式
- 建立长连接通信
- 处理跨标签页通信

## 练习 6.1: 基础消息通信

### 任务

实现 Popup 和 Background 之间的通信。

### 步骤

1. Background 设置消息监听:

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  // 存储状态
  let counter = 0;
  const history: string[] = [];

  browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
    console.log('Received message:', message, 'from:', sender);

    switch (message.type) {
      case 'GET_COUNTER':
        return Promise.resolve({ counter });

      case 'INCREMENT':
        counter += message.amount || 1;
        return Promise.resolve({ counter });

      case 'DECREMENT':
        counter -= message.amount || 1;
        return Promise.resolve({ counter });

      case 'RESET':
        counter = 0;
        return Promise.resolve({ counter });

      case 'ADD_HISTORY':
        history.push(message.item);
        return Promise.resolve({ success: true, length: history.length });

      case 'GET_HISTORY':
        return Promise.resolve({ history });

      case 'CLEAR_HISTORY':
        history.length = 0;
        return Promise.resolve({ success: true });

      default:
        return Promise.resolve({ error: 'Unknown message type' });
    }
  });
});
```

2. Popup 发送消息:

```tsx
// entrypoints/popup/App.tsx
import { useState, useEffect } from 'react';

function App() {
  const [counter, setCounter] = useState(0);
  const [loading, setLoading] = useState(true);

  // 获取初始值
  useEffect(() => {
    browser.runtime.sendMessage({ type: 'GET_COUNTER' })
      .then(response => {
        setCounter(response.counter);
        setLoading(false);
      });
  }, []);

  const increment = async () => {
    const response = await browser.runtime.sendMessage({ 
      type: 'INCREMENT', 
      amount: 1 
    });
    setCounter(response.counter);
  };

  const decrement = async () => {
    const response = await browser.runtime.sendMessage({ 
      type: 'DECREMENT',
      amount: 1
    });
    setCounter(response.counter);
  };

  const reset = async () => {
    const response = await browser.runtime.sendMessage({ type: 'RESET' });
    setCounter(response.counter);
  };

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <div style={{ padding: 20, minWidth: 200 }}>
      <h2>Counter: {counter}</h2>
      <div style={{ display: 'flex', gap: 8 }}>
        <button onClick={decrement}>-</button>
        <button onClick={increment}>+</button>
        <button onClick={reset}>Reset</button>
      </div>
    </div>
  );
}

export default App;
```

### 验证

- [ ] 打开 Popup 显示当前计数
- [ ] 点击按钮可以增减计数
- [ ] 关闭再打开 Popup,计数保持

---

## 练习 6.2: Content Script 通信

### 任务

实现 Content Script 与 Background 的双向通信。

### 步骤

1. Content Script 发送消息:

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['*://*/*'],

  main() {
    // 页面加载时通知 background
    browser.runtime.sendMessage({
      type: 'PAGE_LOADED',
      data: {
        url: window.location.href,
        title: document.title,
        timestamp: Date.now(),
      },
    });

    // 监听来自 background/popup 的消息
    browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
      console.log('Content script received:', message);

      switch (message.type) {
        case 'GET_PAGE_INFO':
          return Promise.resolve({
            url: window.location.href,
            title: document.title,
            links: document.querySelectorAll('a').length,
            images: document.querySelectorAll('img').length,
          });

        case 'HIGHLIGHT_TEXT':
          highlightText(message.text);
          return Promise.resolve({ success: true });

        case 'SCROLL_TO_TOP':
          window.scrollTo({ top: 0, behavior: 'smooth' });
          return Promise.resolve({ success: true });

        case 'GET_SELECTION':
          return Promise.resolve({
            text: window.getSelection()?.toString() || '',
          });
      }
    });
  },
});

function highlightText(text: string) {
  const regex = new RegExp(`(${text})`, 'gi');
  const walker = document.createTreeWalker(
    document.body,
    NodeFilter.SHOW_TEXT,
    null
  );

  const textNodes: Text[] = [];
  while (walker.nextNode()) {
    textNodes.push(walker.currentNode as Text);
  }

  textNodes.forEach(node => {
    if (node.textContent?.match(regex)) {
      const span = document.createElement('span');
      span.innerHTML = node.textContent.replace(
        regex,
        '<mark style="background: yellow;">$1</mark>'
      );
      node.parentNode?.replaceChild(span, node);
    }
  });
}
```

2. 从 Popup 向 Content Script 发送消息:

```tsx
// entrypoints/popup/App.tsx
import { useState, useEffect } from 'react';

function App() {
  const [pageInfo, setPageInfo] = useState<any>(null);
  const [searchText, setSearchText] = useState('');

  useEffect(() => {
    getPageInfo();
  }, []);

  const getPageInfo = async () => {
    const [tab] = await browser.tabs.query({ 
      active: true, 
      currentWindow: true 
    });
    
    if (tab?.id) {
      try {
        const info = await browser.tabs.sendMessage(tab.id, {
          type: 'GET_PAGE_INFO',
        });
        setPageInfo(info);
      } catch (e) {
        console.error('Failed to get page info:', e);
      }
    }
  };

  const highlightText = async () => {
    if (!searchText) return;
    
    const [tab] = await browser.tabs.query({ 
      active: true, 
      currentWindow: true 
    });
    
    if (tab?.id) {
      await browser.tabs.sendMessage(tab.id, {
        type: 'HIGHLIGHT_TEXT',
        text: searchText,
      });
    }
  };

  const scrollToTop = async () => {
    const [tab] = await browser.tabs.query({ 
      active: true, 
      currentWindow: true 
    });
    
    if (tab?.id) {
      await browser.tabs.sendMessage(tab.id, {
        type: 'SCROLL_TO_TOP',
      });
    }
  };

  return (
    <div style={{ padding: 20, minWidth: 300 }}>
      <h2>Page Info</h2>
      
      {pageInfo ? (
        <div style={{ fontSize: 12, marginBottom: 16 }}>
          <p><strong>Title:</strong> {pageInfo.title}</p>
          <p><strong>Links:</strong> {pageInfo.links}</p>
          <p><strong>Images:</strong> {pageInfo.images}</p>
        </div>
      ) : (
        <p>Loading...</p>
      )}

      <div style={{ marginBottom: 12 }}>
        <input
          type="text"
          value={searchText}
          onChange={e => setSearchText(e.target.value)}
          placeholder="Text to highlight"
          style={{ width: '100%', padding: 8 }}
        />
        <button onClick={highlightText} style={{ marginTop: 8 }}>
          Highlight
        </button>
      </div>

      <button onClick={scrollToTop}>Scroll to Top</button>
    </div>
  );
}

export default App;
```

### 验证

- [ ] Popup 显示当前页面信息
- [ ] 输入文本并点击 Highlight,页面中的匹配文本被高亮
- [ ] 点击 Scroll to Top 页面滚动到顶部

---

## 练习 6.3: 长连接 (Port)

### 任务

建立持久化的消息通道。

### 步骤

1. Background 处理端口连接:

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  const connections = new Map<string, browser.Runtime.Port>();

  browser.runtime.onConnect.addListener((port) => {
    console.log('Port connected:', port.name);
    connections.set(port.name, port);

    // 监听端口消息
    port.onMessage.addListener((message) => {
      console.log('Port message:', port.name, message);

      switch (message.type) {
        case 'SUBSCRIBE':
          // 客户端订阅更新
          port.postMessage({ type: 'SUBSCRIBED', channel: message.channel });
          break;

        case 'BROADCAST':
          // 广播给所有连接
          connections.forEach((conn, name) => {
            if (name !== port.name) {
              conn.postMessage({
                type: 'BROADCAST_MESSAGE',
                from: port.name,
                data: message.data,
              });
            }
          });
          break;
      }
    });

    // 处理断开连接
    port.onDisconnect.addListener(() => {
      console.log('Port disconnected:', port.name);
      connections.delete(port.name);
    });

    // 发送欢迎消息
    port.postMessage({ 
      type: 'CONNECTED',
      activeConnections: connections.size,
    });
  });

  // 定时推送更新
  setInterval(() => {
    const update = {
      type: 'TIME_UPDATE',
      time: new Date().toISOString(),
    };
    connections.forEach(port => {
      port.postMessage(update);
    });
  }, 5000);
});
```

2. Popup 使用端口连接:

```tsx
// entrypoints/popup/App.tsx
import { useState, useEffect, useRef } from 'react';

function App() {
  const [messages, setMessages] = useState<string[]>([]);
  const [connected, setConnected] = useState(false);
  const portRef = useRef<browser.Runtime.Port | null>(null);

  useEffect(() => {
    // 建立连接
    const port = browser.runtime.connect({ 
      name: 'popup-' + Date.now() 
    });
    portRef.current = port;

    // 监听消息
    port.onMessage.addListener((message) => {
      setMessages(prev => [...prev, JSON.stringify(message)]);
      
      if (message.type === 'CONNECTED') {
        setConnected(true);
      }
    });

    // 监听断开
    port.onDisconnect.addListener(() => {
      setConnected(false);
    });

    // 订阅更新
    port.postMessage({ type: 'SUBSCRIBE', channel: 'updates' });

    return () => {
      port.disconnect();
    };
  }, []);

  const sendBroadcast = () => {
    portRef.current?.postMessage({
      type: 'BROADCAST',
      data: { message: 'Hello from popup!', time: Date.now() },
    });
  };

  return (
    <div style={{ padding: 20, width: 350, maxHeight: 400 }}>
      <h2>Port Communication</h2>
      
      <p>
        Status: {connected ? 
          <span style={{ color: 'green' }}>Connected</span> : 
          <span style={{ color: 'red' }}>Disconnected</span>
        }
      </p>

      <button onClick={sendBroadcast}>Send Broadcast</button>

      <div style={{ 
        marginTop: 16, 
        maxHeight: 200, 
        overflow: 'auto',
        background: '#f5f5f5',
        padding: 8,
        fontSize: 12,
      }}>
        {messages.map((msg, i) => (
          <div key={i} style={{ marginBottom: 4 }}>
            {msg}
          </div>
        ))}
      </div>
    </div>
  );
}

export default App;
```

### 验证

- [ ] 打开 Popup 显示 Connected 状态
- [ ] 每 5 秒收到时间更新
- [ ] 点击 Broadcast 发送广播消息

---

## 练习 6.4: 跨标签页通信

### 任务

实现多个标签页之间的通信。

### 步骤

1. 创建通信中心:

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  // 标签页状态存储
  const tabStates = new Map<number, any>();

  // 监听来自 content script 的状态更新
  browser.runtime.onMessage.addListener((message, sender) => {
    if (message.type === 'UPDATE_TAB_STATE' && sender.tab?.id) {
      tabStates.set(sender.tab.id, {
        ...message.state,
        tabId: sender.tab.id,
        url: sender.tab.url,
        lastUpdate: Date.now(),
      });
      
      // 广播给其他标签页
      broadcastToTabs({
        type: 'TAB_STATE_CHANGED',
        tabId: sender.tab.id,
        state: message.state,
      }, sender.tab.id);
      
      return Promise.resolve({ success: true });
    }

    if (message.type === 'GET_ALL_TAB_STATES') {
      return Promise.resolve({
        states: Object.fromEntries(tabStates),
      });
    }

    if (message.type === 'SEND_TO_TAB') {
      return sendToTab(message.targetTabId, message.data);
    }
  });

  // 清理关闭的标签页
  browser.tabs.onRemoved.addListener((tabId) => {
    tabStates.delete(tabId);
  });

  async function broadcastToTabs(message: any, excludeTabId?: number) {
    const tabs = await browser.tabs.query({});
    for (const tab of tabs) {
      if (tab.id && tab.id !== excludeTabId) {
        try {
          await browser.tabs.sendMessage(tab.id, message);
        } catch {
          // 忽略无法接收消息的标签页
        }
      }
    }
  }

  async function sendToTab(tabId: number, data: any) {
    try {
      return await browser.tabs.sendMessage(tabId, {
        type: 'DIRECT_MESSAGE',
        data,
      });
    } catch (e) {
      return { error: 'Failed to send message' };
    }
  }
});
```

2. Content Script 参与通信:

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['*://*/*'],

  main() {
    // 报告当前状态
    const reportState = () => {
      browser.runtime.sendMessage({
        type: 'UPDATE_TAB_STATE',
        state: {
          scrollY: window.scrollY,
          title: document.title,
          focusedElement: document.activeElement?.tagName,
        },
      });
    };

    // 初始报告
    reportState();

    // 监听滚动
    window.addEventListener('scroll', debounce(reportState, 500));

    // 监听来自其他标签页的消息
    browser.runtime.onMessage.addListener((message) => {
      if (message.type === 'TAB_STATE_CHANGED') {
        console.log('Other tab state changed:', message.tabId, message.state);
      }

      if (message.type === 'DIRECT_MESSAGE') {
        console.log('Direct message received:', message.data);
        // 可以在这里处理直接消息
        return Promise.resolve({ received: true });
      }

      if (message.type === 'SYNC_SCROLL') {
        window.scrollTo({
          top: message.scrollY,
          behavior: 'smooth',
        });
      }
    });
  },
});

function debounce<T extends (...args: any[]) => any>(
  fn: T,
  delay: number
): T {
  let timer: ReturnType<typeof setTimeout>;
  return ((...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => fn(...args), delay);
  }) as T;
}
```

### 验证

- [ ] 在多个标签页中打开带有 content script 的页面
- [ ] 一个标签页滚动时,其他标签页收到通知

---

## 练习 6.5: 类型安全的消息

### 任务

创建类型安全的消息系统。

### 步骤

```typescript
// utils/messaging.ts

// 定义消息类型
export interface Messages {
  // Background 处理的消息
  'counter:get': { response: { value: number } };
  'counter:set': { data: { value: number }; response: { success: boolean } };
  'counter:increment': { data: { amount: number }; response: { value: number } };
  
  // Content Script 处理的消息
  'page:getInfo': { response: { title: string; url: string } };
  'page:highlight': { data: { text: string }; response: { count: number } };
}

// 类型提取工具
type MessageData<K extends keyof Messages> = 
  Messages[K] extends { data: infer D } ? D : undefined;
type MessageResponse<K extends keyof Messages> = 
  Messages[K]['response'];

// 发送消息到 Background
export async function sendToBackground<K extends keyof Messages>(
  type: K,
  ...args: MessageData<K> extends undefined ? [] : [MessageData<K>]
): Promise<MessageResponse<K>> {
  const data = args[0];
  return browser.runtime.sendMessage({ type, data });
}

// 发送消息到 Content Script
export async function sendToTab<K extends keyof Messages>(
  tabId: number,
  type: K,
  ...args: MessageData<K> extends undefined ? [] : [MessageData<K>]
): Promise<MessageResponse<K>> {
  const data = args[0];
  return browser.tabs.sendMessage(tabId, { type, data });
}

// 消息处理器类型
type MessageHandler<K extends keyof Messages> = (
  data: MessageData<K>,
  sender: browser.Runtime.MessageSender
) => Promise<MessageResponse<K>> | MessageResponse<K>;

// 创建消息处理器
export function createMessageHandler(
  handlers: Partial<{
    [K in keyof Messages]: MessageHandler<K>
  }>
) {
  return (
    message: { type: keyof Messages; data?: any },
    sender: browser.Runtime.MessageSender
  ) => {
    const handler = handlers[message.type];
    if (handler) {
      return Promise.resolve(handler(message.data, sender));
    }
  };
}
```

使用示例:

```typescript
// entrypoints/background.ts
import { createMessageHandler } from '~/utils/messaging';

export default defineBackground(() => {
  let counter = 0;

  const handler = createMessageHandler({
    'counter:get': async () => {
      return { value: counter };
    },
    'counter:set': async (data) => {
      counter = data.value;
      return { success: true };
    },
    'counter:increment': async (data) => {
      counter += data.amount;
      return { value: counter };
    },
  });

  browser.runtime.onMessage.addListener(handler);
});
```

```tsx
// entrypoints/popup/App.tsx
import { sendToBackground } from '~/utils/messaging';

function App() {
  const [value, setValue] = useState(0);

  useEffect(() => {
    // 类型安全!
    sendToBackground('counter:get').then(res => {
      setValue(res.value); // res.value 类型为 number
    });
  }, []);

  const increment = async () => {
    // 类型安全: 必须提供 amount
    const res = await sendToBackground('counter:increment', { amount: 1 });
    setValue(res.value);
  };

  return (
    <div>
      <p>Value: {value}</p>
      <button onClick={increment}>+1</button>
    </div>
  );
}
```

### 验证

- [ ] TypeScript 类型检查通过
- [ ] 错误的消息类型会报错
- [ ] 响应数据类型正确

---

## 挑战练习

### 挑战: 实现事件总线

创建一个发布-订阅模式的事件系统:

```typescript
// utils/eventBus.ts
type EventCallback = (data: any) => void;

class EventBus {
  private listeners = new Map<string, Set<EventCallback>>();
  private port: browser.Runtime.Port | null = null;

  connect() {
    this.port = browser.runtime.connect({ name: 'event-bus' });
    
    this.port.onMessage.addListener((message) => {
      if (message.type === 'EVENT') {
        this.emit(message.event, message.data, true);
      }
    });
  }

  on(event: string, callback: EventCallback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event)!.add(callback);

    return () => {
      this.listeners.get(event)?.delete(callback);
    };
  }

  emit(event: string, data?: any, local = false) {
    // 本地触发
    this.listeners.get(event)?.forEach(cb => cb(data));

    // 广播到其他部分
    if (!local && this.port) {
      this.port.postMessage({ type: 'EVENT', event, data });
    }
  }
}

export const eventBus = new EventBus();
```

---

## 自我检查

1. sendMessage 和 connect 有什么区别?
2. 如何向特定标签页发送消息?
3. 异步消息处理器必须返回什么?
4. 如何在 content script 中接收消息?
5. Port 断开后会发生什么?

## 参考答案

1. sendMessage 是一次性的请求-响应,connect 建立持久连接
2. 使用 `browser.tabs.sendMessage(tabId, message)`
3. 必须返回 `Promise` 或使用 `sendResponse`
4. 使用 `browser.runtime.onMessage.addListener`
5. `onDisconnect` 事件触发,需要重新连接
