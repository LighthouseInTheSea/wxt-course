# WXT 实战练习 12: 远程代码与脚本注入

## 练习目标

通过本练习,你将:
- 理解远程代码处理机制
- 掌握主世界脚本注入
- 实现动态脚本加载
- 处理 CSP 限制

## 练习 12.1: 远程代码打包

### 任务

将远程脚本打包到扩展中。

### 背景

Chrome MV3 不允许执行远程代码,WXT 提供了 `url:` 前缀来解决这个问题。

### 步骤

1. 定义远程脚本入口:

```typescript
// entrypoints/analytics.content/index.ts
export default defineContentScript({
  matches: ['*://*/*'],
  main() {
    // 这个脚本会自动打包 Google Analytics
  },
});
```

2. 使用 url: 前缀导入:

```typescript
// entrypoints/analytics.content/index.ts
// WXT 会在构建时下载并打包此脚本
import 'url:https://www.googletagmanager.com/gtag/js?id=G-XXXXXX';

export default defineContentScript({
  matches: ['*://*/*'],
  runAt: 'document_start',
  main() {
    // @ts-ignore
    window.dataLayer = window.dataLayer || [];
    function gtag(...args: any[]) {
      // @ts-ignore
      window.dataLayer.push(args);
    }
    gtag('js', new Date());
    gtag('config', 'G-XXXXXX');
  },
});
```

3. 声明类型:

```typescript
// types/url-imports.d.ts
declare module 'url:*' {
  const url: string;
  export default url;
}
```

### 验证

```bash
# 构建并检查输出
pnpm build
ls -la .output/chrome-mv3/
```

---

## 练习 12.2: 主世界脚本注入

### 任务

将脚本注入到页面的主世界执行。

### 背景

Content Script 运行在隔离的世界,无法访问页面的 JavaScript 变量。要访问页面变量,需要注入到主世界。

### 步骤

1. 创建要注入的脚本:

```typescript
// entrypoints/injected.ts
export default defineUnlistedScript(() => {
  // 这里可以访问页面的 window 对象
  console.log('[Injected] Running in main world');
  
  // 修改页面函数
  const originalFetch = window.fetch;
  window.fetch = async function(...args) {
    console.log('[Injected] Fetch intercepted:', args[0]);
    return originalFetch.apply(this, args);
  };

  // 监听页面事件
  window.addEventListener('customEvent', (e) => {
    console.log('[Injected] Custom event received:', e);
  });

  // 暴露 API 给页面
  (window as any).__extensionAPI = {
    getVersion: () => '1.0.0',
    sendMessage: (msg: any) => {
      window.postMessage({ type: 'FROM_EXTENSION', payload: msg }, '*');
    },
  };
});
```

2. 从 Content Script 注入:

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['*://*/*'],
  
  async main() {
    // 方法1: 使用 injectScript (推荐)
    await injectScript('/injected.js', {
      keepInDom: true,
    });

    // 监听来自注入脚本的消息
    window.addEventListener('message', (event) => {
      if (event.data?.type === 'FROM_EXTENSION') {
        console.log('[Content] Message from injected:', event.data.payload);
      }
    });

    // 向注入脚本发送消息
    window.postMessage({ type: 'TO_INJECTED', payload: 'hello' }, '*');
  },
});
```

3. 配置 web_accessible_resources:

```typescript
// wxt.config.ts
export default defineConfig({
  manifest: {
    web_accessible_resources: [
      {
        resources: ['injected.js'],
        matches: ['*://*/*'],
      },
    ],
  },
});
```

### 方法对比

| 方法 | 优点 | 缺点 |
|------|------|------|
| injectScript | WXT 内置,简单 | 需要配置 web_accessible_resources |
| 动态创建 script | 灵活 | 需要手动处理 |
| executeScript | 权限控制好 | 需要 activeTab 权限 |

---

## 练习 12.3: 动态脚本执行

### 任务

使用 scripting API 动态执行脚本。

### 步骤

1. 声明权限:

```typescript
// wxt.config.ts
export default defineConfig({
  manifest: {
    permissions: ['scripting', 'activeTab'],
  },
});
```

2. 从 Background 执行脚本:

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  // 监听扩展图标点击
  browser.action.onClicked.addListener(async (tab) => {
    if (!tab.id) return;

    // 执行函数
    const results = await browser.scripting.executeScript({
      target: { tabId: tab.id },
      func: () => {
        // 这个函数在页面中执行
        const title = document.title;
        const links = document.querySelectorAll('a').length;
        return { title, links };
      },
    });

    console.log('Page info:', results[0].result);
  });

  // 执行带参数的函数
  async function highlightText(tabId: number, text: string, color: string) {
    await browser.scripting.executeScript({
      target: { tabId },
      func: (searchText, bgColor) => {
        const walker = document.createTreeWalker(
          document.body,
          NodeFilter.SHOW_TEXT,
          null
        );

        while (walker.nextNode()) {
          const node = walker.currentNode;
          if (node.textContent?.includes(searchText)) {
            const span = document.createElement('span');
            span.style.backgroundColor = bgColor;
            const range = document.createRange();
            range.selectNodeContents(node);
            range.surroundContents(span);
          }
        }
      },
      args: [text, color],
    });
  }

  // 注入 CSS
  async function injectStyles(tabId: number) {
    await browser.scripting.insertCSS({
      target: { tabId },
      css: `
        .extension-highlight {
          background-color: yellow !important;
          border: 2px solid orange !important;
        }
      `,
    });
  }

  // 执行文件
  async function executeFile(tabId: number) {
    await browser.scripting.executeScript({
      target: { tabId },
      files: ['content-scripts/helper.js'],
    });
  }
});
```

3. 指定执行世界:

```typescript
// 在隔离世界执行 (默认)
await browser.scripting.executeScript({
  target: { tabId },
  func: () => { /* ... */ },
  world: 'ISOLATED',
});

// 在主世界执行
await browser.scripting.executeScript({
  target: { tabId },
  func: () => {
    // 可以访问页面变量
    console.log('Page variable:', (window as any).somePageVar);
  },
  world: 'MAIN',
});
```

---

## 练习 12.4: 绕过 CSP 限制

### 任务

处理严格 CSP 的页面。

### 背景

某些页面有严格的 Content-Security-Policy,阻止内联脚本执行。

### 解决方案

1. 使用 scripting API (推荐):

```typescript
// 从 background 执行,不受页面 CSP 限制
await browser.scripting.executeScript({
  target: { tabId },
  func: () => {
    // 这里的代码不受页面 CSP 限制
  },
});
```

2. 使用文件注入:

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['*://*/*'],
  
  main() {
    // 不要使用内联脚本
    // const script = document.createElement('script');
    // script.textContent = 'console.log("inline")'; // CSP 会阻止

    // 使用文件注入
    const script = document.createElement('script');
    script.src = browser.runtime.getURL('/injected.js');
    document.head.appendChild(script);
  },
});
```

3. 使用 Blob URL (可能被 CSP 阻止):

```typescript
// 某些 CSP 策略会阻止 blob:
function injectViaBlob(code: string) {
  const blob = new Blob([code], { type: 'text/javascript' });
  const url = URL.createObjectURL(blob);
  const script = document.createElement('script');
  script.src = url;
  script.onload = () => URL.revokeObjectURL(url);
  document.head.appendChild(script);
}
```

---

## 练习 12.5: 与注入脚本通信

### 任务

实现 Content Script 与注入脚本的双向通信。

### 步骤

1. 定义通信协议:

```typescript
// types/messages.ts
interface InjectedMessage {
  source: 'extension-injected';
  type: string;
  payload: any;
}

interface ContentMessage {
  source: 'extension-content';
  type: string;
  payload: any;
}
```

2. 注入脚本:

```typescript
// entrypoints/injected.ts
export default defineUnlistedScript(() => {
  // 发送消息到 Content Script
  function sendToContent(type: string, payload: any) {
    window.postMessage({
      source: 'extension-injected',
      type,
      payload,
    }, '*');
  }

  // 接收来自 Content Script 的消息
  window.addEventListener('message', (event) => {
    if (event.source !== window) return;
    if (event.data?.source !== 'extension-content') return;

    const { type, payload } = event.data;
    
    switch (type) {
      case 'GET_PAGE_DATA':
        // 获取页面数据
        sendToContent('PAGE_DATA', {
          title: document.title,
          url: location.href,
          // 访问页面 JS 变量
          customData: (window as any).pageConfig || null,
        });
        break;
        
      case 'MODIFY_PAGE':
        // 修改页面
        (window as any).somePageFunction?.(payload);
        sendToContent('MODIFY_RESULT', { success: true });
        break;
    }
  });

  // 初始化完成通知
  sendToContent('INJECTED_READY', { version: '1.0.0' });
});
```

3. Content Script:

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['*://*/*'],
  
  async main() {
    // 创建通信管理器
    const injectedComm = new InjectedCommunicator();
    
    // 等待注入脚本就绪
    await injectedComm.waitForReady();
    
    // 获取页面数据
    const pageData = await injectedComm.send('GET_PAGE_DATA');
    console.log('Page data:', pageData);
    
    // 修改页面
    const result = await injectedComm.send('MODIFY_PAGE', { action: 'highlight' });
    console.log('Modify result:', result);
  },
});

class InjectedCommunicator {
  private listeners = new Map<string, (payload: any) => void>();
  private readyPromise: Promise<void>;
  private readyResolve!: () => void;

  constructor() {
    this.readyPromise = new Promise(resolve => {
      this.readyResolve = resolve;
    });

    window.addEventListener('message', (event) => {
      if (event.source !== window) return;
      if (event.data?.source !== 'extension-injected') return;

      const { type, payload } = event.data;
      
      if (type === 'INJECTED_READY') {
        this.readyResolve();
        return;
      }

      const listener = this.listeners.get(type);
      if (listener) {
        listener(payload);
        this.listeners.delete(type);
      }
    });

    // 注入脚本
    injectScript('/injected.js');
  }

  async waitForReady(): Promise<void> {
    return this.readyPromise;
  }

  send<T = any>(type: string, payload?: any): Promise<T> {
    return new Promise((resolve) => {
      // 注册响应监听器
      const responseType = type.replace('GET_', '').replace('MODIFY_', '') + '_RESULT';
      this.listeners.set(type === 'GET_PAGE_DATA' ? 'PAGE_DATA' : responseType, resolve);

      // 发送消息
      window.postMessage({
        source: 'extension-content',
        type,
        payload,
      }, '*');
    });
  }
}
```

---

## 练习 12.6: 代码分割与懒加载

### 任务

实现按需加载脚本。

### 步骤

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['*://*/*'],
  
  async main(ctx) {
    // 只在需要时加载重量级模块
    const analyzeButton = document.querySelector('#analyze');
    
    if (analyzeButton) {
      analyzeButton.addEventListener('click', async () => {
        // 动态导入
        const { analyzePageContent } = await import('~/utils/analyzer');
        const result = await analyzePageContent(document);
        console.log('Analysis:', result);
      });
    }

    // 条件加载 UI
    const shouldShowUI = await checkShouldShowUI();
    if (shouldShowUI) {
      // 懒加载 UI 组件
      const { createUI } = await import('./ui');
      createUI(ctx);
    }
  },
});

async function checkShouldShowUI(): Promise<boolean> {
  const settings = await storage.getItem('local:settings');
  return settings?.enableUI ?? true;
}
```

---

## 挑战练习

### 挑战: 实现完整的页面增强系统

创建一个能够:
1. 注入到主世界
2. 拦截页面 API
3. 与 Content Script 通信
4. 与 Background 通信

```typescript
// entrypoints/enhancer.ts
export default defineUnlistedScript(() => {
  class PageEnhancer {
    private originalAPIs = new Map<string, Function>();

    constructor() {
      this.interceptFetch();
      this.interceptXHR();
      this.setupCommunication();
    }

    private interceptFetch() {
      const original = window.fetch;
      this.originalAPIs.set('fetch', original);

      window.fetch = async (...args) => {
        const [url, options] = args;
        
        // 通知扩展
        this.notify('fetch', { url: url.toString(), method: options?.method });
        
        try {
          const response = await original.apply(window, args);
          this.notify('fetchComplete', { 
            url: url.toString(), 
            status: response.status 
          });
          return response;
        } catch (error) {
          this.notify('fetchError', { url: url.toString(), error: String(error) });
          throw error;
        }
      };
    }

    private interceptXHR() {
      const originalOpen = XMLHttpRequest.prototype.open;
      const originalSend = XMLHttpRequest.prototype.send;
      const self = this;

      XMLHttpRequest.prototype.open = function(method: string, url: string, ...rest: any[]) {
        (this as any)._url = url;
        (this as any)._method = method;
        return originalOpen.apply(this, [method, url, ...rest] as any);
      };

      XMLHttpRequest.prototype.send = function(body?: any) {
        self.notify('xhr', { 
          url: (this as any)._url, 
          method: (this as any)._method 
        });
        return originalSend.call(this, body);
      };
    }

    private setupCommunication() {
      window.addEventListener('message', (event) => {
        if (event.data?.source !== 'extension-content') return;
        
        const { type, payload, id } = event.data;
        
        this.handleCommand(type, payload).then(result => {
          window.postMessage({
            source: 'extension-injected',
            type: 'RESPONSE',
            id,
            payload: result,
          }, '*');
        });
      });
    }

    private async handleCommand(type: string, payload: any) {
      switch (type) {
        case 'GET_WINDOW_VAR':
          return (window as any)[payload.name];
        case 'CALL_WINDOW_FUNC':
          return (window as any)[payload.name]?.(...payload.args);
        case 'RESTORE_API':
          this.restoreAPI(payload.name);
          return { restored: true };
        default:
          return { error: 'Unknown command' };
      }
    }

    private restoreAPI(name: string) {
      const original = this.originalAPIs.get(name);
      if (original) {
        (window as any)[name] = original;
      }
    }

    private notify(type: string, data: any) {
      window.postMessage({
        source: 'extension-injected',
        type: 'NOTIFICATION',
        payload: { type, data },
      }, '*');
    }
  }

  new PageEnhancer();
});
```

---

## 自我检查

1. url: 前缀有什么作用?
2. 如何将脚本注入到主世界?
3. scripting API 需要什么权限?
4. Content Script 如何与注入脚本通信?
5. 如何绕过页面 CSP?

## 参考答案

1. 在构建时下载远程脚本并打包到扩展中,解决 MV3 不允许执行远程代码的问题
2. 使用 defineUnlistedScript + injectScript,或使用 scripting.executeScript 的 world: 'MAIN'
3. 需要 scripting 权限,可能还需要 activeTab 或 host_permissions
4. 通过 window.postMessage 传递消息
5. 使用 scripting API 从 background 执行,或使用文件注入而非内联脚本
