# WXT 实战练习 10: 自动导入系统

## 练习目标

通过本练习,你将:
- 理解 WXT 自动导入机制
- 配置自定义自动导入
- 解决 ESLint 集成问题
- 优化开发体验

## 练习 10.1: 默认自动导入

### 任务

了解 WXT 默认提供的自动导入。

### WXT 内置自动导入

以下 API 无需手动导入即可使用:

```typescript
// entrypoints/background.ts
// defineBackground 自动导入
export default defineBackground(() => {
  console.log('Background loaded');
});

// entrypoints/content.ts
// defineContentScript 自动导入
export default defineContentScript({
  matches: ['*://*/*'],
  main() {
    console.log('Content script loaded');
  },
});

// 任意文件中
// browser API 自动导入
browser.runtime.sendMessage({ type: 'hello' });

// storage 自动导入
import { storage } from 'wxt/storage';
```

### 查看所有自动导入

```bash
# 生成类型声明
pnpm wxt prepare

# 查看生成的类型
cat .wxt/types/imports.d.ts
```

### 验证

创建文件直接使用自动导入:

```typescript
// entrypoints/test.content.ts
export default defineContentScript({
  matches: ['*://example.com/*'],
  main() {
    // 直接使用,无需导入
    browser.runtime.sendMessage({ type: 'test' });
  },
});
```

- [ ] 无导入语句也能正常工作
- [ ] TypeScript 类型提示正常

---

## 练习 10.2: 自定义自动导入

### 任务

配置项目特定的自动导入。

### 步骤

1. 配置 wxt.config.ts:

```typescript
// wxt.config.ts
import { defineConfig } from 'wxt';

export default defineConfig({
  imports: {
    // 添加预设
    presets: [
      // 自动导入 React hooks
      {
        from: 'react',
        imports: [
          'useState',
          'useEffect',
          'useCallback',
          'useMemo',
          'useRef',
          'useContext',
          'createContext',
        ],
      },
    ],

    // 自动导入目录
    dirs: [
      'utils',           // ~/utils/* 自动导入
      'hooks',           // ~/hooks/* 自动导入
      'composables',     // ~/composables/* 自动导入
    ],

    // 自定义导入
    imports: [
      // 从特定模块导入
      { name: 'clsx', from: 'clsx' },
      { name: 'default', as: 'dayjs', from: 'dayjs' },
      
      // 类型导入
      { name: 'Storage', from: 'wxt/storage', type: true },
    ],
  },
});
```

2. 创建工具函数:

```typescript
// utils/format.ts
export function formatDate(date: Date | number): string {
  return new Intl.DateTimeFormat('zh-CN', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
  }).format(date);
}

export function formatNumber(num: number): string {
  return new Intl.NumberFormat('zh-CN').format(num);
}

export function truncate(str: string, length: number): string {
  if (str.length <= length) return str;
  return str.slice(0, length) + '...';
}
```

```typescript
// hooks/useDebounce.ts
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay);
    return () => clearTimeout(timer);
  }, [value, delay]);

  return debouncedValue;
}
```

3. 使用自动导入:

```tsx
// entrypoints/popup/App.tsx
// 无需手动导入 useState, useEffect, formatDate, useDebounce 等

function App() {
  // React hooks 自动导入
  const [count, setCount] = useState(0);
  const [search, setSearch] = useState('');
  
  // 自定义 hooks 自动导入
  const debouncedSearch = useDebounce(search, 300);
  
  // 工具函数自动导入
  const formattedDate = formatDate(Date.now());
  const formattedCount = formatNumber(count * 1000);

  useEffect(() => {
    console.log('Debounced search:', debouncedSearch);
  }, [debouncedSearch]);

  return (
    <div style={{ padding: 20 }}>
      <p>日期: {formattedDate}</p>
      <p>计数: {formattedCount}</p>
      
      <input
        value={search}
        onChange={e => setSearch(e.target.value)}
        placeholder="搜索..."
      />
      
      <button onClick={() => setCount(c => c + 1)}>+1</button>
    </div>
  );
}

export default App;
```

### 验证

```bash
# 重新生成类型
pnpm wxt prepare

# 检查类型文件
cat .wxt/types/imports.d.ts
```

- [ ] 自定义函数可以自动导入
- [ ] TypeScript 无报错

---

## 练习 10.3: ESLint 集成

### 任务

解决 ESLint 对自动导入的报错。

### 问题

ESLint 默认会报错:
```
'useState' is not defined. eslint(no-undef)
```

### 解决方案 (ESLint 9 Flat Config)

```javascript
// eslint.config.js
import js from '@eslint/js';
import tseslint from 'typescript-eslint';

// 导入 WXT 生成的 globals
import autoImports from './.wxt/eslint-auto-imports.mjs';

export default [
  js.configs.recommended,
  ...tseslint.configs.recommended,
  
  // WXT 自动导入配置
  {
    languageOptions: {
      globals: {
        ...autoImports.globals,
      },
    },
  },
  
  // 其他规则...
];
```

### 解决方案 (ESLint 8 Legacy)

1. 配置 wxt.config.ts 生成 eslintrc:

```typescript
// wxt.config.ts
export default defineConfig({
  imports: {
    eslintrc: {
      enabled: true,
    },
  },
});
```

2. 在 .eslintrc 中扩展:

```json
{
  "extends": [
    "./.wxt/eslintrc-auto-import.json"
  ]
}
```

### 验证

```bash
# 运行 ESLint
pnpm eslint src/

# 应该没有 'xxx is not defined' 错误
```

---

## 练习 10.4: 显式导入

### 任务

在需要时使用显式导入。

### 场景

某些情况下你可能需要显式导入:
- 导入在 IDE 中看起来更清晰
- 需要重命名导入
- 使用不在自动导入列表中的模块

### 步骤

```typescript
// 使用 #imports 显式导入自动导入的模块
import { useState, useEffect, browser } from '#imports';

// 正常导入非自动导入的模块
import { someFunction } from '~/utils/other';
```

完整示例:

```tsx
// entrypoints/popup/App.tsx
// 混合使用显式和隐式导入
import { createContext, useContext } from '#imports';  // 显式
import type { ReactNode } from 'react';  // 类型导入

// 创建 Context
const ThemeContext = createContext<'light' | 'dark'>('light');

export function ThemeProvider({ children }: { children: ReactNode }) {
  // useState 隐式自动导入
  const [theme, setTheme] = useState<'light' | 'dark'>('light');

  return (
    <ThemeContext.Provider value={theme}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  return useContext(ThemeContext);
}
```

---

## 练习 10.5: 禁用自动导入

### 任务

了解如何禁用或限制自动导入。

### 完全禁用

```typescript
// wxt.config.ts
export default defineConfig({
  imports: false,
});
```

### 禁用特定导入

```typescript
// wxt.config.ts
export default defineConfig({
  imports: {
    // 只保留 WXT 核心导入
    presets: [],
    dirs: [],
    imports: [],
  },
});
```

### 排除特定目录

```typescript
// wxt.config.ts
export default defineConfig({
  imports: {
    dirs: [
      'utils',
      'hooks',
    ],
    // 排除特定文件
    excludeDirs: [
      'utils/internal',
    ],
  },
});
```

---

## 练习 10.6: 类型安全的自动导入

### 任务

确保自动导入的类型安全。

### 步骤

1. 确保运行 prepare:

```json
{
  "scripts": {
    "postinstall": "wxt prepare"
  }
}
```

2. 配置 tsconfig.json:

```json
{
  "extends": "./.wxt/tsconfig.json",
  "compilerOptions": {
    "strict": true
  }
}
```

3. 创建类型声明:

```typescript
// types/auto-imports.d.ts
// 手动声明特殊的全局类型
declare const __DEV__: boolean;
declare const __VERSION__: string;
```

4. 使用:

```typescript
// entrypoints/background.ts
export default defineBackground(() => {
  if (__DEV__) {
    console.log('Development mode');
  }
  
  console.log('Version:', __VERSION__);
});
```

在 wxt.config.ts 中定义:

```typescript
// wxt.config.ts
import pkg from './package.json';

export default defineConfig({
  vite: () => ({
    define: {
      __DEV__: JSON.stringify(process.env.NODE_ENV !== 'production'),
      __VERSION__: JSON.stringify(pkg.version),
    },
  }),
});
```

---

## 挑战练习

### 挑战: 创建完整的自动导入配置

创建一个完整的配置,包含:
- React 所有常用 hooks
- 项目工具函数
- 第三方库 (dayjs, lodash-es 等)
- 自定义 composables

```typescript
// wxt.config.ts
import { defineConfig } from 'wxt';

export default defineConfig({
  imports: {
    presets: [
      // React
      {
        from: 'react',
        imports: [
          'useState', 'useEffect', 'useCallback', 'useMemo',
          'useRef', 'useContext', 'createContext', 'useReducer',
          'forwardRef', 'memo', 'lazy', 'Suspense',
        ],
      },
      // React DOM
      {
        from: 'react-dom',
        imports: ['createPortal'],
      },
    ],
    
    imports: [
      // dayjs
      { name: 'default', as: 'dayjs', from: 'dayjs' },
      // clsx
      { name: 'clsx', from: 'clsx' },
      { name: 'default', as: 'cn', from: 'clsx' },
      // lodash
      { name: 'debounce', from: 'lodash-es' },
      { name: 'throttle', from: 'lodash-es' },
      { name: 'cloneDeep', from: 'lodash-es' },
    ],
    
    dirs: [
      'utils',
      'hooks',
      'composables',
      'stores',
    ],
    
    eslintrc: {
      enabled: true,
    },
  },
});
```

---

## 自我检查

1. WXT 默认自动导入哪些 API?
2. 如何添加自定义自动导入目录?
3. 如何解决 ESLint 对自动导入的报错?
4. 如何显式导入自动导入的模块?
5. postinstall 中的 wxt prepare 做什么?

## 参考答案

1. defineBackground, defineContentScript, browser, storage 等 WXT 核心 API
2. 在 wxt.config.ts 的 imports.dirs 数组中添加目录路径
3. 配置 imports.eslintrc.enabled 并在 eslint 配置中扩展生成的文件
4. 使用 `import { xxx } from '#imports'`
5. 生成类型声明文件,确保 TypeScript 识别自动导入的模块
