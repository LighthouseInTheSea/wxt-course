# WXT 实战练习 05: 内容脚本开发

## 练习目标

通过本练习,你将:
- 掌握内容脚本注入方式
- 实现 DOM 操作和监听
- 创建页面内 UI 组件
- 使用 Shadow DOM 隔离样式

## 练习 5.1: 基础内容脚本

### 任务

创建一个在所有网页上运行的内容脚本。

### 步骤

```typescript
// entrypoints/content.ts
export default defineContentScript({
  matches: ['*://*/*'],
  
  main() {
    console.log('Content script loaded on:', window.location.href);

    // 添加页面加载时间显示
    const loadTime = performance.now().toFixed(2);
    console.log(`Page loaded in ${loadTime}ms`);

    // 统计页面元素
    const stats = {
      links: document.querySelectorAll('a').length,
      images: document.querySelectorAll('img').length,
      scripts: document.querySelectorAll('script').length,
      forms: document.querySelectorAll('form').length,
    };
    console.table(stats);
  },
});
```

### 验证

- [ ] 访问任意网页
- [ ] 打开开发者工具控制台
- [ ] 看到页面统计信息

---

## 练习 5.2: 特定网站内容脚本

### 任务

为 GitHub 创建专用内容脚本。

### 步骤

```typescript
// entrypoints/content.github.ts
export default defineContentScript({
  matches: ['*://*.github.com/*'],
  runAt: 'document_end',

  main() {
    console.log('GitHub enhancer loaded');

    // 高亮显示仓库统计
    highlightRepoStats();

    // 添加快速复制按钮
    addCopyButtons();

    // 监听 AJAX 导航 (GitHub 使用 pjax)
    observeNavigation();
  },
});

function highlightRepoStats() {
  // 高亮 star 数量
  const starButton = document.querySelector('[aria-label*="star"]');
  if (starButton) {
    (starButton as HTMLElement).style.background = '#fff3cd';
  }
}

function addCopyButtons() {
  // 为代码块添加复制按钮
  document.querySelectorAll('pre').forEach((pre) => {
    if (pre.querySelector('.copy-btn')) return;

    const btn = document.createElement('button');
    btn.className = 'copy-btn';
    btn.textContent = 'Copy';
    btn.style.cssText = `
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 8px;
      background: #0969da;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    `;

    btn.addEventListener('click', async () => {
      const code = pre.textContent || '';
      await navigator.clipboard.writeText(code);
      btn.textContent = 'Copied!';
      setTimeout(() => {
        btn.textContent = 'Copy';
      }, 2000);
    });

    pre.style.position = 'relative';
    pre.appendChild(btn);
  });
}

function observeNavigation() {
  // GitHub 使用 turbo/pjax 进行导航
  document.addEventListener('turbo:load', () => {
    console.log('GitHub navigation detected');
    highlightRepoStats();
    addCopyButtons();
  });
}
```

### 验证

- [ ] 访问任意 GitHub 仓库页面
- [ ] 代码块出现 Copy 按钮
- [ ] 点击按钮可以复制代码

---

## 练习 5.3: 使用 CSS 注入

### 任务

注入自定义样式美化页面。

### 步骤

1. 创建 CSS 文件:

```css
/* entrypoints/content.github.css */
/* 美化 GitHub 页面 */

/* 更圆润的头像 */
.avatar {
  border-radius: 50% !important;
  transition: transform 0.2s;
}

.avatar:hover {
  transform: scale(1.1);
}

/* 高亮当前行 */
.blob-code:hover {
  background-color: #fff8c5 !important;
}

/* 美化按钮 */
.btn-primary {
  transition: all 0.2s !important;
}

.btn-primary:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

/* 标签页指示器 */
.UnderlineNav-item.selected {
  border-bottom-color: #f97316 !important;
  border-bottom-width: 3px !important;
}
```

2. 配置 CSS 注入:

```typescript
// entrypoints/content.github.ts
export default defineContentScript({
  matches: ['*://*.github.com/*'],
  css: ['content.github.css'], // 自动注入 CSS
  
  main() {
    console.log('GitHub styles injected');
  },
});
```

### 验证

- [ ] 访问 GitHub
- [ ] 头像变为圆形
- [ ] 鼠标悬停时头像放大

---

## 练习 5.4: Shadow DOM UI

### 任务

使用 Shadow DOM 创建隔离的 UI 组件。

### 步骤

```typescript
// entrypoints/overlay.content.tsx
import { createShadowRootUi } from 'wxt/client';
import ReactDOM from 'react-dom/client';

export default defineContentScript({
  matches: ['*://*/*'],
  
  async main(ctx) {
    const ui = await createShadowRootUi(ctx, {
      name: 'floating-panel',
      position: 'inline',
      anchor: 'body',
      append: 'first',
      
      onMount(container) {
        const root = ReactDOM.createRoot(container);
        root.render(<FloatingPanel />);
        return root;
      },
      
      onRemove(root) {
        root?.unmount();
      },
    });

    ui.mount();
  },
});

function FloatingPanel() {
  const [isOpen, setIsOpen] = useState(false);
  const [position, setPosition] = useState({ x: 20, y: 20 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });

  const handleMouseDown = (e: React.MouseEvent) => {
    setIsDragging(true);
    setDragOffset({
      x: e.clientX - position.x,
      y: e.clientY - position.y,
    });
  };

  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (isDragging) {
        setPosition({
          x: e.clientX - dragOffset.x,
          y: e.clientY - dragOffset.y,
        });
      }
    };

    const handleMouseUp = () => {
      setIsDragging(false);
    };

    if (isDragging) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    }

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDragging, dragOffset]);

  return (
    <>
      <style>{`
        .floating-button {
          position: fixed;
          width: 48px;
          height: 48px;
          border-radius: 50%;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          border: none;
          cursor: grab;
          display: flex;
          align-items: center;
          justify-content: center;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          z-index: 999999;
          transition: transform 0.2s;
        }
        .floating-button:hover {
          transform: scale(1.1);
        }
        .floating-button:active {
          cursor: grabbing;
        }
        .panel {
          position: fixed;
          width: 300px;
          background: white;
          border-radius: 12px;
          box-shadow: 0 8px 32px rgba(0,0,0,0.2);
          z-index: 999998;
          overflow: hidden;
        }
        .panel-header {
          padding: 16px;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          font-weight: bold;
        }
        .panel-content {
          padding: 16px;
        }
        .panel-item {
          padding: 8px 0;
          border-bottom: 1px solid #eee;
        }
        .panel-item:last-child {
          border-bottom: none;
        }
      `}</style>

      <button
        className="floating-button"
        style={{ left: position.x, top: position.y }}
        onMouseDown={handleMouseDown}
        onClick={() => !isDragging && setIsOpen(!isOpen)}
      >
        <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
          <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5" 
                stroke="white" strokeWidth="2" fill="none"/>
        </svg>
      </button>

      {isOpen && (
        <div 
          className="panel"
          style={{ 
            left: position.x + 60, 
            top: position.y 
          }}
        >
          <div className="panel-header">
            页面信息
          </div>
          <div className="panel-content">
            <div className="panel-item">
              <strong>标题:</strong><br />
              {document.title}
            </div>
            <div className="panel-item">
              <strong>URL:</strong><br />
              <span style={{ fontSize: 12, wordBreak: 'break-all' }}>
                {window.location.href}
              </span>
            </div>
            <div className="panel-item">
              <strong>元素统计:</strong><br />
              链接: {document.querySelectorAll('a').length} | 
              图片: {document.querySelectorAll('img').length}
            </div>
          </div>
        </div>
      )}
    </>
  );
}

import { useState, useEffect } from 'react';
```

### 验证

- [ ] 页面左上角出现浮动按钮
- [ ] 可以拖拽按钮移动位置
- [ ] 点击按钮显示信息面板
- [ ] 样式不影响原页面

---

## 练习 5.5: DOM 变化监听

### 任务

监听页面 DOM 变化并做出响应。

### 步骤

```typescript
// entrypoints/observer.content.ts
export default defineContentScript({
  matches: ['*://*/*'],
  
  main(ctx) {
    console.log('DOM observer started');

    // 创建 MutationObserver
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        // 监听新增节点
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach((node) => {
            if (node instanceof HTMLElement) {
              // 检测广告容器
              if (isAdElement(node)) {
                console.log('Ad element detected:', node);
                // node.style.display = 'none'; // 可以隐藏广告
              }

              // 检测视频元素
              if (node.tagName === 'VIDEO') {
                console.log('Video element added');
                enhanceVideo(node as HTMLVideoElement);
              }

              // 检测弹窗
              if (isModalElement(node)) {
                console.log('Modal detected');
              }
            }
          });
        }

        // 监听属性变化
        if (mutation.type === 'attributes') {
          const target = mutation.target as HTMLElement;
          if (mutation.attributeName === 'class') {
            // 类名变化处理
          }
        }
      }
    });

    // 开始观察
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['class', 'style'],
    });

    // 清理函数
    ctx.onInvalidated(() => {
      observer.disconnect();
      console.log('Observer disconnected');
    });
  },
});

function isAdElement(element: HTMLElement): boolean {
  const adPatterns = [
    'ad', 'ads', 'advert', 'advertisement',
    'banner', 'sponsor', 'promoted',
  ];
  
  const classAndId = (element.className + ' ' + element.id).toLowerCase();
  return adPatterns.some(pattern => classAndId.includes(pattern));
}

function isModalElement(element: HTMLElement): boolean {
  const style = window.getComputedStyle(element);
  return (
    style.position === 'fixed' &&
    style.zIndex !== 'auto' &&
    parseInt(style.zIndex) > 1000
  );
}

function enhanceVideo(video: HTMLVideoElement) {
  // 添加播放速度控制
  video.addEventListener('loadedmetadata', () => {
    console.log('Video duration:', video.duration);
  });

  // 记住播放进度
  const videoId = video.src || video.currentSrc;
  const savedTime = localStorage.getItem(`video_progress_${videoId}`);
  if (savedTime) {
    video.currentTime = parseFloat(savedTime);
  }

  video.addEventListener('timeupdate', () => {
    localStorage.setItem(
      `video_progress_${videoId}`,
      video.currentTime.toString()
    );
  });
}
```

### 验证

- [ ] 访问有动态内容的网站
- [ ] 控制台显示 DOM 变化日志
- [ ] 视频播放进度被记住

---

## 练习 5.6: 表单增强

### 任务

增强网页表单功能。

### 步骤

```typescript
// entrypoints/form-enhancer.content.ts
export default defineContentScript({
  matches: ['*://*/*'],
  
  main() {
    enhanceForms();
    
    // 监听动态加载的表单
    const observer = new MutationObserver(() => {
      enhanceForms();
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true,
    });
  },
});

function enhanceForms() {
  document.querySelectorAll('form').forEach((form) => {
    if (form.dataset.enhanced) return;
    form.dataset.enhanced = 'true';

    // 1. 自动保存草稿
    const formId = form.id || form.action || 'form_' + Math.random();
    
    form.querySelectorAll('input, textarea').forEach((input) => {
      const field = input as HTMLInputElement | HTMLTextAreaElement;
      const fieldId = field.name || field.id;
      if (!fieldId) return;

      // 恢复保存的值
      const savedValue = localStorage.getItem(`draft_${formId}_${fieldId}`);
      if (savedValue && !field.value) {
        field.value = savedValue;
      }

      // 保存输入
      field.addEventListener('input', () => {
        localStorage.setItem(`draft_${formId}_${fieldId}`, field.value);
      });
    });

    // 2. 添加字符计数
    form.querySelectorAll('textarea').forEach((textarea) => {
      const counter = document.createElement('div');
      counter.style.cssText = `
        font-size: 12px;
        color: #666;
        text-align: right;
        margin-top: 4px;
      `;
      
      const maxLength = textarea.maxLength > 0 ? textarea.maxLength : null;
      
      const updateCounter = () => {
        const current = textarea.value.length;
        if (maxLength) {
          counter.textContent = `${current}/${maxLength}`;
          counter.style.color = current > maxLength * 0.9 ? '#f44336' : '#666';
        } else {
          counter.textContent = `${current} 字符`;
        }
      };

      textarea.addEventListener('input', updateCounter);
      updateCounter();
      textarea.parentNode?.insertBefore(counter, textarea.nextSibling);
    });

    // 3. 密码强度指示
    form.querySelectorAll('input[type="password"]').forEach((input) => {
      const passwordInput = input as HTMLInputElement;
      
      // 跳过确认密码框
      if (passwordInput.name?.includes('confirm')) return;

      const indicator = document.createElement('div');
      indicator.style.cssText = `
        height: 4px;
        margin-top: 4px;
        border-radius: 2px;
        transition: all 0.3s;
      `;

      const updateStrength = () => {
        const password = passwordInput.value;
        const strength = calculatePasswordStrength(password);
        
        const colors = ['#f44336', '#ff9800', '#ffeb3b', '#8bc34a', '#4caf50'];
        const widths = ['20%', '40%', '60%', '80%', '100%'];
        
        indicator.style.background = colors[strength];
        indicator.style.width = widths[strength];
      };

      passwordInput.addEventListener('input', updateStrength);
      passwordInput.parentNode?.insertBefore(indicator, passwordInput.nextSibling);
    });

    // 4. 提交时清除草稿
    form.addEventListener('submit', () => {
      const keys = Object.keys(localStorage).filter(key => 
        key.startsWith(`draft_${formId}_`)
      );
      keys.forEach(key => localStorage.removeItem(key));
    });
  });
}

function calculatePasswordStrength(password: string): number {
  let strength = 0;
  
  if (password.length >= 8) strength++;
  if (password.length >= 12) strength++;
  if (/[A-Z]/.test(password)) strength++;
  if (/[0-9]/.test(password)) strength++;
  if (/[^A-Za-z0-9]/.test(password)) strength++;
  
  return Math.min(strength, 4);
}
```

### 验证

- [ ] 访问有表单的网页
- [ ] 输入内容后刷新页面,内容被恢复
- [ ] textarea 显示字符计数
- [ ] 密码框显示强度指示器

---

## 挑战练习

### 挑战: 创建阅读模式

实现类似 Safari 阅读模式的功能:

```typescript
// entrypoints/reader.content.tsx
import { createShadowRootUi } from 'wxt/client';
import ReactDOM from 'react-dom/client';
import { useState, useEffect } from 'react';

export default defineContentScript({
  matches: ['*://*/*'],
  
  async main(ctx) {
    // 监听来自 popup 的消息
    browser.runtime.onMessage.addListener((message) => {
      if (message.type === 'TOGGLE_READER_MODE') {
        toggleReaderMode();
      }
    });
  },
});

async function toggleReaderMode() {
  const existing = document.getElementById('reader-mode-overlay');
  if (existing) {
    existing.remove();
    return;
  }

  // 提取正文内容
  const article = extractArticle();
  if (!article) {
    alert('无法提取文章内容');
    return;
  }

  // 创建阅读模式覆盖层
  const overlay = document.createElement('div');
  overlay.id = 'reader-mode-overlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: #fefefe;
    z-index: 999999;
    overflow-y: auto;
    padding: 40px;
  `;

  overlay.innerHTML = `
    <style>
      #reader-content {
        max-width: 700px;
        margin: 0 auto;
        font-family: Georgia, serif;
        font-size: 20px;
        line-height: 1.8;
        color: #333;
      }
      #reader-content h1 {
        font-size: 32px;
        margin-bottom: 24px;
      }
      #reader-content p {
        margin-bottom: 16px;
      }
      #reader-content img {
        max-width: 100%;
        height: auto;
      }
      #close-reader {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 8px 16px;
        background: #333;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
    </style>
    <button id="close-reader">关闭阅读模式</button>
    <div id="reader-content">
      <h1>${article.title}</h1>
      ${article.content}
    </div>
  `;

  document.body.appendChild(overlay);
  
  document.getElementById('close-reader')?.addEventListener('click', () => {
    overlay.remove();
  });
}

function extractArticle() {
  // 简单的文章提取逻辑
  const title = document.querySelector('h1')?.textContent || document.title;
  
  // 查找主要内容区域
  const selectors = ['article', 'main', '.post-content', '.article-content', '.entry-content'];
  let content = null;
  
  for (const selector of selectors) {
    const element = document.querySelector(selector);
    if (element) {
      content = element.innerHTML;
      break;
    }
  }
  
  if (!content) {
    // 回退: 获取最大的文本块
    const paragraphs = Array.from(document.querySelectorAll('p'));
    content = paragraphs
      .filter(p => p.textContent && p.textContent.length > 100)
      .map(p => p.outerHTML)
      .join('');
  }

  return content ? { title, content } : null;
}
```

---

## 自我检查

1. content script 运行在什么环境?
2. 如何确保 CSS 不影响原页面?
3. runAt 有哪些选项?
4. 如何监听 SPA 的路由变化?
5. ctx.onInvalidated 有什么用?

## 参考答案

1. 隔离的内容脚本环境 (isolated world),可访问 DOM 但不能访问页面 JS 变量
2. 使用 Shadow DOM (createShadowRootUi) 或 CSS Modules
3. `document_start`, `document_end`, `document_idle` (默认)
4. 使用 MutationObserver 监听 DOM 变化,或监听 popstate/hashchange 事件
5. 在扩展更新/卸载时清理资源 (断开 observer、移除事件监听等)
