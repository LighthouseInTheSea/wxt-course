# WXT 沉浸式翻译插件实战 - 第二章: 后台服务开发

> **导航**: [上一章: 项目初始化](./01-项目初始化与架构设计.md) | [下一章: 内容脚本开发](./03-内容脚本开发.md) | [返回目录](../README.md)
>
> **相关基础**: [后台脚本开发](../WXT-基础教程/04-后台脚本开发.md) | [消息通信机制](../WXT-基础教程/06-消息通信机制.md)

---

## 2.1 后台服务概述

后台服务(Background Service)是浏览器插件的"大脑"和"中枢神经"，虽然用户看不到它，但它在幕后默默处理着所有核心逻辑。

**后台服务的职责**:
- **消息枢纽**: 接收来自 Content Script、Popup、Options 的消息并分发
- **API 网关**: 统一调用翻译 API，处理认证、缓存、限流
- **状态管理**: 管理插件全局状态，同步到各个组件
- **事件处理**: 响应快捷键、右键菜单、安装/更新事件
- **定时任务**: 执行定期清理、数据同步等后台任务

### 架构角色

后台服务在整个插件架构中处于核心位置:

```
+----------------+          +------------------+          +----------------+
|   Content      |  ---->   |    Background    |  ---->   |   Translation  |
|   Script       |          |    Service       |          |   API          |
+----------------+  <----   +------------------+  <----   +----------------+
       ^                           |
       |                           v
+----------------+          +------------------+
|    Popup       |          |    Storage       |
+----------------+          +------------------+
```

**数据流说明**:
1. Content Script 检测到需要翻译的文本，发送消息给 Background
2. Background 检查缓存，如果没有则调用翻译 API
3. Background 将结果缓存并返回给 Content Script
4. Content Script 将翻译结果渲染到页面

---

## 2.2 创建后台服务入口

### src/entrypoints/background.ts

后台服务的入口文件需要使用 `defineBackground` 函数定义。这个函数的回调会在插件启动时执行:

```typescript
import { defineBackground } from 'wxt/sandbox';
import { setupMessageHandler } from '@/services/messaging';
import { setupContextMenus } from '@/services/contextMenu';
import { setupCommands } from '@/services/commands';
import { settingsStorage } from '@/stores/storage';

export default defineBackground(() => {
  console.log('[Background] Service started');
  
  // 1. 初始化消息处理器
  // 这是最重要的一步，让后台服务能够接收和响应消息
  setupMessageHandler();
  
  // 2. 初始化右键菜单
  // 用户右键点击时显示"翻译选中文本"等选项
  setupContextMenus();
  
  // 3. 初始化快捷键命令
  // 响应用户按下快捷键的事件
  setupCommands();
  
  // 4. 监听设置变化
  // 当用户在 Options 页面修改设置时，通知所有标签页更新
  settingsStorage.watch((newSettings) => {
    console.log('[Background] Settings changed:', newSettings);
    notifyAllTabs({ type: 'SETTINGS_CHANGED', payload: newSettings });
  });
  
  // 5. 监听安装/更新事件
  // 首次安装时打开欢迎页面，更新时可以显示更新日志
  browser.runtime.onInstalled.addListener(async (details) => {
    if (details.reason === 'install') {
      console.log('[Background] Extension installed');
      // 打开欢迎页面，引导用户完成初始设置
      await browser.tabs.create({
        url: browser.runtime.getURL('/options.html#welcome'),
      });
    } else if (details.reason === 'update') {
      console.log('[Background] Extension updated');
      // 可以在这里显示更新日志
    }
  });
});

/**
 * 通知所有标签页
 * 用于广播设置变化等全局事件
 */
async function notifyAllTabs(message: unknown): Promise<void> {
  const tabs = await browser.tabs.query({});
  for (const tab of tabs) {
    if (tab.id) {
      try {
        await browser.tabs.sendMessage(tab.id, message);
      } catch {
        // 忽略无法发送消息的标签页 (如 chrome:// 页面)
      }
    }
  }
}
```

**关键点解释**:
1. `defineBackground` 回调在 MV3 中作为 Service Worker 执行，可能随时被终止，所以不要依赖全局变量保存状态
2. 所有初始化逻辑应该是幂等的，因为 Service Worker 可能多次启动
3. 使用 `browser.runtime.onInstalled` 处理首次安装和更新场景

---

## 2.3 消息处理系统

消息系统是后台服务最核心的功能，负责接收和分发来自各个组件的消息。我们采用**处理器模式**来组织代码，让消息处理逻辑清晰可维护。

### src/services/messaging/index.ts

```typescript
import { browser } from 'wxt/browser';
import { MessageType, type ExtensionMessage, type MessageResponse } from '@/types/message';
import { handleTranslateText, handleTranslatePage } from './handlers/translate';
import { handleGetSettings, handleUpdateSettings } from './handlers/settings';
import { handleGetStatus, handleToggleTranslate } from './handlers/status';

/**
 * 消息处理器类型定义
 * T: 消息载荷类型
 * R: 响应数据类型
 */
type MessageHandler<T = unknown, R = unknown> = (
  payload: T,
  sender: browser.Runtime.MessageSender
) => Promise<R>;

/**
 * 处理器映射表
 * 将消息类型映射到对应的处理函数
 * 
 * 这种设计的好处:
 * 1. 添加新消息类型只需添加一行映射
 * 2. 每个处理器可以独立测试
 * 3. 类型安全，IDE 可以提供自动完成
 */
const handlers: Record<MessageType, MessageHandler> = {
  [MessageType.TRANSLATE_TEXT]: handleTranslateText,
  [MessageType.TRANSLATE_PAGE]: handleTranslatePage,
  [MessageType.TRANSLATE_RESULT]: async () => {}, // 仅用于响应，不需要处理
  [MessageType.GET_SETTINGS]: handleGetSettings,
  [MessageType.UPDATE_SETTINGS]: handleUpdateSettings,
  [MessageType.SETTINGS_CHANGED]: async () => {}, // 仅用于通知，不需要处理
  [MessageType.GET_STATUS]: handleGetStatus,
  [MessageType.TOGGLE_TRANSLATE]: handleToggleTranslate,
};

/**
 * 设置消息监听
 * 这是消息系统的入口，在后台服务启动时调用
 */
export function setupMessageHandler(): void {
  browser.runtime.onMessage.addListener(
    (
      message: ExtensionMessage,
      sender: browser.Runtime.MessageSender
    ): Promise<MessageResponse> | true => {
      const handler = handlers[message.type];
      
      // 处理未知消息类型
      if (!handler) {
        console.warn('[Messaging] Unknown message type:', message.type);
        return Promise.resolve({
          success: false,
          error: `Unknown message type: ${message.type}`,
        });
      }
      
      // 异步处理消息
      // 注意: 返回 Promise 而不是直接返回值，以支持异步操作
      return (async () => {
        try {
          const result = await handler(message.payload, sender);
          return { success: true, data: result };
        } catch (error) {
          console.error('[Messaging] Handler error:', error);
          return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error',
          };
        }
      })();
    }
  );
  
  console.log('[Messaging] Handler initialized');
}

/**
 * 发送消息到指定标签页
 * 用于后台服务主动向 Content Script 发送消息
 */
export async function sendToTab<T>(
  tabId: number,
  message: ExtensionMessage
): Promise<MessageResponse<T>> {
  try {
    return await browser.tabs.sendMessage(tabId, message);
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to send message',
    };
  }
}

/**
 * 发送消息到后台服务
 * 用于 Content Script、Popup 向后台发送消息
 */
export async function sendToBackground<T>(
  message: ExtensionMessage
): Promise<MessageResponse<T>> {
  try {
    return await browser.runtime.sendMessage(message);
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to send message',
    };
  }
}
```

### src/services/messaging/handlers/translate.ts

翻译处理器是最核心的业务逻辑，包含缓存检查、API 调用、结果存储等功能:

```typescript
import type { TranslateRequest, TranslateResult } from '@/types/translate';
import { translateText } from '@/services/translate';
import { settingsStorage, addToHistory, getFromCache, setToCache } from '@/stores/storage';

/**
 * 处理单个文本翻译请求
 * 
 * 处理流程:
 * 1. 检查缓存，命中则直接返回
 * 2. 调用翻译 API
 * 3. 缓存结果
 * 4. 添加到历史记录
 */
export async function handleTranslateText(
  payload: TranslateRequest,
  sender: browser.Runtime.MessageSender
): Promise<TranslateResult> {
  const { text, from, to } = payload;
  
  // Step 1: 检查缓存
  // 使用 "源语言:目标语言:原文" 作为缓存键
  const cacheKey = `${from}:${to}:${text}`;
  const cached = await getFromCache(cacheKey);
  
  if (cached) {
    console.log('[Translate] Cache hit');
    return {
      originalText: text,
      translatedText: cached,
      from,
      to,
      service: 'cache' as any,
      timestamp: Date.now(),
    };
  }
  
  // Step 2: 获取用户设置，确定使用哪个翻译服务
  const settings = await settingsStorage.getValue();
  
  // Step 3: 调用翻译服务
  const result = await translateText({
    text,
    from,
    to,
    service: settings.primaryService,
  });
  
  // Step 4: 缓存结果 (异步执行，不阻塞返回)
  setToCache(cacheKey, result.translatedText).catch(console.error);
  
  // Step 5: 添加到历史记录 (异步执行)
  addToHistory(result).catch(console.error);
  
  return result;
}

/**
 * 处理整页翻译请求
 * 
 * 整页翻译需要处理大量文本，采用分批处理策略:
 * 1. 将文本数组分成小批次
 * 2. 每批次并行处理
 * 3. 批次之间添加延迟，避免 API 限流
 */
export async function handleTranslatePage(
  payload: { texts: string[]; from: string; to: string },
  sender: browser.Runtime.MessageSender
): Promise<TranslateResult[]> {
  const { texts, from, to } = payload;
  const settings = await settingsStorage.getValue();
  
  // 批量大小: 每次处理 10 个文本
  const batchSize = 10;
  const results: TranslateResult[] = [];
  
  for (let i = 0; i < texts.length; i += batchSize) {
    const batch = texts.slice(i, i + batchSize);
    
    // 并行处理当前批次
    const batchResults = await Promise.all(
      batch.map(async (text) => {
        try {
          return await handleTranslateText(
            { text, from: from as any, to: to as any },
            sender
          );
        } catch (error) {
          // 单个翻译失败不影响其他，返回原文
          return {
            originalText: text,
            translatedText: text,
            from: from as any,
            to: to as any,
            service: settings.primaryService,
            timestamp: Date.now(),
          };
        }
      })
    );
    
    results.push(...batchResults);
    
    // 批次之间添加 100ms 延迟，避免 API 限流
    if (i + batchSize < texts.length) {
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }
  
  return results;
}
```

---

## 2.4 翻译服务层

翻译服务层采用**策略模式**，支持多个翻译引擎，并实现自动降级:

### src/services/translate/index.ts

```typescript
import type { TranslateRequest, TranslateResult, TranslateService } from '@/types/translate';
import { googleTranslate } from './google';
import { deeplTranslate } from './deepl';
import { openaiTranslate } from './openai';
import { customTranslate } from './custom';
import { settingsStorage } from '@/stores/storage';

/**
 * 翻译服务映射表
 * 使用策略模式，每个翻译服务是一个独立的策略
 */
const services: Record<TranslateService, typeof googleTranslate> = {
  google: googleTranslate,
  deepl: deeplTranslate,
  openai: openaiTranslate,
  custom: customTranslate,
};

/**
 * 主翻译函数
 * 
 * 特性:
 * 1. 根据用户设置选择翻译服务
 * 2. 主服务失败时自动切换到备用服务
 * 3. 统一的错误处理
 */
export async function translateText(request: TranslateRequest): Promise<TranslateResult> {
  const settings = await settingsStorage.getValue();
  const service = request.service || settings.primaryService;
  
  const translator = services[service];
  
  if (!translator) {
    throw new Error(`Unknown translation service: ${service}`);
  }
  
  try {
    return await translator(request);
  } catch (error) {
    // 降级策略: 如果配置了备用服务且与主服务不同，尝试使用备用服务
    if (settings.fallbackService && settings.fallbackService !== service) {
      console.warn(`[Translate] ${service} failed, trying fallback:`, settings.fallbackService);
      const fallbackTranslator = services[settings.fallbackService];
      return await fallbackTranslator(request);
    }
    throw error;
  }
}

/**
 * 批量翻译
 * 将多个文本一次性翻译
 */
export async function translateBatch(
  texts: string[],
  from: string,
  to: string
): Promise<string[]> {
  const results = await Promise.all(
    texts.map((text) =>
      translateText({ text, from: from as any, to: to as any })
    )
  );
  return results.map((r) => r.translatedText);
}

/**
 * 语言检测
 * 简单实现，通过正则检测文本语言
 */
export async function detectLanguage(text: string): Promise<string> {
  const chineseRegex = /[\u4e00-\u9fa5]/;
  const japaneseRegex = /[\u3040-\u309f\u30a0-\u30ff]/;
  const koreanRegex = /[\uac00-\ud7af]/;
  
  if (chineseRegex.test(text)) return 'zh-CN';
  if (japaneseRegex.test(text)) return 'ja';
  if (koreanRegex.test(text)) return 'ko';
  
  return 'en';
}
```

### src/services/translate/google.ts

Google 翻译使用免费的 API 接口:

```typescript
import type { TranslateRequest, TranslateResult } from '@/types/translate';

/**
 * Google 翻译 API
 * 使用免费的 translate.googleapis.com 接口
 * 
 * 注意: 这个接口没有官方文档，可能随时变化
 * 生产环境建议使用付费的 Cloud Translation API
 */
export async function googleTranslate(request: TranslateRequest): Promise<TranslateResult> {
  const { text, from, to } = request;
  
  // 构建请求 URL
  const url = new URL('https://translate.googleapis.com/translate_a/single');
  url.searchParams.set('client', 'gtx');
  url.searchParams.set('sl', from === 'auto' ? 'auto' : from);
  url.searchParams.set('tl', to);
  url.searchParams.set('dt', 't');
  url.searchParams.set('q', text);
  
  try {
    const response = await fetch(url.toString());
    
    if (!response.ok) {
      throw new Error(`Google Translate API error: ${response.status}`);
    }
    
    const data = await response.json();
    
    // 解析响应
    // 响应格式: [[["翻译结果","原文",null,null,10]],null,"en",...]
    const translatedText = data[0]
      ?.map((item: any[]) => item[0])
      .filter(Boolean)
      .join('') || text;
    
    const detectedLang = data[2] || from;
    
    return {
      originalText: text,
      translatedText,
      from: detectedLang,
      to,
      service: 'google',
      timestamp: Date.now(),
    };
  } catch (error) {
    console.error('[Google Translate] Error:', error);
    throw error;
  }
}
```

### src/services/translate/openai.ts

OpenAI 翻译使用 ChatGPT API，质量更高但速度较慢:

```typescript
import type { TranslateRequest, TranslateResult } from '@/types/translate';
import { settingsStorage } from '@/stores/storage';

/**
 * OpenAI 翻译
 * 使用 GPT-3.5/4 进行翻译，质量更高但成本也更高
 */
export async function openaiTranslate(request: TranslateRequest): Promise<TranslateResult> {
  const { text, from, to } = request;
  const settings = await settingsStorage.getValue();
  
  const apiKey = settings.apiKeys.openai;
  if (!apiKey) {
    throw new Error('OpenAI API key not configured');
  }
  
  // 语言名称映射，用于构建 prompt
  const langNames: Record<string, string> = {
    'zh-CN': 'Simplified Chinese',
    'zh-TW': 'Traditional Chinese',
    'en': 'English',
    'ja': 'Japanese',
    'ko': 'Korean',
    'fr': 'French',
    'de': 'German',
    'es': 'Spanish',
    'ru': 'Russian',
  };
  
  const sourceLang = from === 'auto' ? 'the source language' : langNames[from];
  const targetLang = langNames[to] || to;
  
  // 构建翻译 prompt
  // 明确指示只输出翻译结果，不要解释
  const prompt = `Translate the following text from ${sourceLang} to ${targetLang}. Only output the translation, no explanations.

Text: ${text}`;
  
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: 'You are a professional translator. Translate accurately while maintaining the original meaning and tone.',
        },
        {
          role: 'user',
          content: prompt,
        },
      ],
      temperature: 0.3, // 较低的温度保证翻译稳定性
      max_tokens: 2000,
    }),
  });
  
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`OpenAI API error: ${error}`);
  }
  
  const data = await response.json();
  const translatedText = data.choices[0]?.message?.content?.trim() || text;
  
  return {
    originalText: text,
    translatedText,
    from,
    to,
    service: 'openai',
    timestamp: Date.now(),
  };
}
```

---

## 2.5 右键菜单

右键菜单提供快捷的翻译入口:

### src/services/contextMenu.ts

```typescript
import { browser } from 'wxt/browser';
import { MessageType } from '@/types/message';
import { sendToTab } from './messaging';

/**
 * 创建右键菜单
 * 在插件启动时调用，创建所有菜单项
 */
export function setupContextMenus(): void {
  // 先清除旧菜单，避免重复创建
  browser.contextMenus.removeAll();
  
  // 菜单 1: 翻译选中文本
  // contexts: ['selection'] 表示只在选中文本时显示
  browser.contextMenus.create({
    id: 'translate-selection',
    title: '翻译选中文本',
    contexts: ['selection'],
  });
  
  // 菜单 2: 翻译整个页面
  // contexts: ['page'] 表示在页面空白处右键时显示
  browser.contextMenus.create({
    id: 'translate-page',
    title: '翻译整个页面',
    contexts: ['page'],
  });
  
  // 分隔符
  browser.contextMenus.create({
    id: 'separator',
    type: 'separator',
    contexts: ['page', 'selection'],
  });
  
  // 菜单 3: 打开设置
  browser.contextMenus.create({
    id: 'open-options',
    title: '打开设置',
    contexts: ['page', 'selection'],
  });
  
  // 监听菜单点击事件
  browser.contextMenus.onClicked.addListener(async (info, tab) => {
    if (!tab?.id) return;
    
    switch (info.menuItemId) {
      case 'translate-selection':
        // 翻译选中的文本
        if (info.selectionText) {
          await sendToTab(tab.id, {
            type: MessageType.TRANSLATE_TEXT,
            timestamp: Date.now(),
            payload: {
              text: info.selectionText,
              from: 'auto',
              to: 'zh-CN',
            },
          });
        }
        break;
        
      case 'translate-page':
        // 触发整页翻译
        await sendToTab(tab.id, {
          type: MessageType.TRANSLATE_PAGE,
          timestamp: Date.now(),
          payload: {},
        });
        break;
        
      case 'open-options':
        // 打开设置页面
        await browser.runtime.openOptionsPage();
        break;
    }
  });
  
  console.log('[ContextMenu] Menus created');
}
```

---

## 2.6 快捷键命令

快捷键让用户可以快速触发翻译功能:

### src/services/commands.ts

```typescript
import { browser } from 'wxt/browser';
import { MessageType } from '@/types/message';
import { sendToTab } from './messaging';

/**
 * 设置快捷键命令监听
 * 快捷键在 manifest 的 commands 字段中定义
 */
export function setupCommands(): void {
  browser.commands.onCommand.addListener(async (command) => {
    console.log('[Commands] Received:', command);
    
    // 获取当前活动的标签页
    const [tab] = await browser.tabs.query({ active: true, currentWindow: true });
    
    if (!tab?.id) return;
    
    switch (command) {
      case 'toggle-translate':
        // 切换翻译状态
        await sendToTab(tab.id, {
          type: MessageType.TOGGLE_TRANSLATE,
          timestamp: Date.now(),
          payload: { url: tab.url || '' },
        });
        break;
    }
  });
  
  console.log('[Commands] Listener initialized');
}

/**
 * 获取快捷键信息
 * 用于在设置页面显示当前快捷键
 */
export async function getShortcuts(): Promise<browser.Commands.Command[]> {
  return await browser.commands.getAll();
}
```

在 `wxt.config.ts` 中配置快捷键:

```typescript
export default defineConfig({
  manifest: {
    commands: {
      'toggle-translate': {
        suggested_key: {
          default: 'Alt+T',
          mac: 'Alt+T',
        },
        description: '开启/关闭翻译',
      },
    },
  },
});
```

---

## 2.7 错误处理与日志

完善的错误处理和日志系统对于调试和维护至关重要:

### src/utils/logger.ts

```typescript
type LogLevel = 'debug' | 'info' | 'warn' | 'error';

const config = {
  enabled: true,
  level: 'debug' as LogLevel,
  prefix: '[ImmersiveTranslate]',
};

const levelWeight: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
};

function createLogger(level: LogLevel) {
  return (...args: unknown[]) => {
    if (!config.enabled) return;
    if (levelWeight[level] < levelWeight[config.level]) return;
    
    const timestamp = new Date().toISOString();
    const prefix = `${config.prefix}[${level.toUpperCase()}][${timestamp}]`;
    
    switch (level) {
      case 'debug': console.debug(prefix, ...args); break;
      case 'info': console.info(prefix, ...args); break;
      case 'warn': console.warn(prefix, ...args); break;
      case 'error': console.error(prefix, ...args); break;
    }
  };
}

export const logger = {
  debug: createLogger('debug'),
  info: createLogger('info'),
  warn: createLogger('warn'),
  error: createLogger('error'),
  setConfig(newConfig: Partial<typeof config>) {
    Object.assign(config, newConfig);
  },
};
```

### src/utils/error.ts

```typescript
/**
 * 翻译错误类
 * 包含错误代码和服务信息，便于定位问题
 */
export class TranslateError extends Error {
  constructor(
    message: string,
    public code: string,
    public service?: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'TranslateError';
  }
}

export const ErrorCodes = {
  NETWORK_ERROR: 'NETWORK_ERROR',
  API_ERROR: 'API_ERROR',
  RATE_LIMIT: 'RATE_LIMIT',
  INVALID_API_KEY: 'INVALID_API_KEY',
  UNSUPPORTED_LANGUAGE: 'UNSUPPORTED_LANGUAGE',
  TEXT_TOO_LONG: 'TEXT_TOO_LONG',
  UNKNOWN: 'UNKNOWN',
} as const;

/**
 * 统一错误处理
 * 将各种错误转换为 TranslateError
 */
export function handleError(error: unknown): TranslateError {
  if (error instanceof TranslateError) {
    return error;
  }
  
  if (error instanceof Error) {
    if (error.message.includes('network') || error.message.includes('fetch')) {
      return new TranslateError('Network error', ErrorCodes.NETWORK_ERROR);
    }
    if (error.message.includes('401') || error.message.includes('403')) {
      return new TranslateError('Invalid API key', ErrorCodes.INVALID_API_KEY);
    }
    if (error.message.includes('429')) {
      return new TranslateError('Rate limit exceeded', ErrorCodes.RATE_LIMIT);
    }
    return new TranslateError(error.message, ErrorCodes.UNKNOWN);
  }
  
  return new TranslateError('Unknown error', ErrorCodes.UNKNOWN, undefined, error);
}
```

---

## 2.8 本章小结

本章实现了后台服务的核心功能:

| 模块 | 功能 | 设计模式 |
|------|------|----------|
| 消息处理系统 | 统一的消息分发和处理 | 处理器模式 |
| 翻译服务层 | 多引擎支持、自动降级 | 策略模式 |
| 右键菜单 | 快捷翻译入口 | 事件驱动 |
| 快捷键命令 | 键盘快捷操作 | 命令模式 |
| 错误处理 | 统一的错误处理和日志 | 单例模式 |

**架构亮点**:
1. **模块化设计**: 每个功能模块独立，易于测试和维护
2. **策略模式**: 翻译服务可扩展，添加新服务只需实现接口
3. **降级机制**: 主服务失败自动切换备用服务
4. **缓存优化**: 翻译结果缓存，减少 API 调用

---

> **下一步**: 了解 [内容脚本开发](./03-内容脚本开发.md)，实现页面文本提取和翻译结果注入
>
> **相关基础**: [后台脚本开发](../WXT-基础教程/04-后台脚本开发.md) | [消息通信机制](../WXT-基础教程/06-消息通信机制.md)
