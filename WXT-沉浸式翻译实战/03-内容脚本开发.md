# WXT 沉浸式翻译插件实战 - 第三章: 内容脚本开发

## 3.1 内容脚本概述

内容脚本(Content Script)运行在网页上下文中,负责:

- 提取页面文本内容
- 注入翻译结果 UI
- 与后台服务通信
- 处理用户交互

### 运行环境特点

| 特性 | 说明 |
|------|------|
| DOM 访问 | 完全访问页面 DOM |
| 隔离环境 | 与页面 JS 隔离,避免冲突 |
| 扩展 API | 可使用部分 browser API |
| 样式隔离 | 需要 Shadow DOM 防止样式冲突 |

## 3.2 创建内容脚本入口

### src/entrypoints/content.tsx

```typescript
import { defineContentScript } from 'wxt/sandbox';
import { createRoot, type Root } from 'react-dom/client';
import { TranslateManager } from '@/components/translate/TranslateManager';
import { FloatingBall } from '@/components/translate/FloatingBall';
import { MessageType } from '@/types/message';
import { settingsStorage } from '@/stores/storage';
import '@/assets/styles/content.css';

export default defineContentScript({
  // 匹配所有网页
  matches: ['<all_urls>'],
  
  // 在文档空闲时运行
  runAt: 'document_idle',
  
  // CSS 注入模式
  cssInjectionMode: 'ui',
  
  async main(ctx) {
    console.log('[Content] Script loaded on:', window.location.href);
    
    // 检查是否应该在此页面运行
    const settings = await settingsStorage.getValue();
    const hostname = window.location.hostname;
    
    if (settings.excludedDomains.includes(hostname)) {
      console.log('[Content] Domain excluded:', hostname);
      return;
    }
    
    // 创建翻译管理器容器
    const managerContainer = document.createElement('div');
    managerContainer.id = 'immersive-translate-manager';
    document.body.appendChild(managerContainer);
    
    // 创建悬浮球容器(使用 Shadow DOM)
    const floatingBallContainer = document.createElement('div');
    floatingBallContainer.id = 'immersive-translate-floating';
    document.body.appendChild(floatingBallContainer);
    
    // 挂载 Shadow DOM
    const shadow = floatingBallContainer.attachShadow({ mode: 'open' });
    const shadowRoot = document.createElement('div');
    shadow.appendChild(shadowRoot);
    
    // 注入样式到 Shadow DOM
    const style = document.createElement('style');
    style.textContent = getFloatingBallStyles();
    shadow.appendChild(style);
    
    // 渲染 React 组件
    let managerRoot: Root | null = null;
    let floatingRoot: Root | null = null;
    
    try {
      managerRoot = createRoot(managerContainer);
      managerRoot.render(<TranslateManager />);
      
      floatingRoot = createRoot(shadowRoot);
      floatingRoot.render(<FloatingBall />);
    } catch (error) {
      console.error('[Content] Failed to render:', error);
    }
    
    // 监听来自后台的消息
    browser.runtime.onMessage.addListener((message, sender) => {
      console.log('[Content] Received message:', message);
      handleMessage(message);
      return true;
    });
    
    // 监听设置变化
    settingsStorage.watch((newSettings) => {
      console.log('[Content] Settings updated');
      // 触发重新渲染
      document.dispatchEvent(new CustomEvent('settings-changed', { 
        detail: newSettings 
      }));
    });
    
    // 清理函数
    ctx.onInvalidated(() => {
      console.log('[Content] Script invalidated, cleaning up');
      managerRoot?.unmount();
      floatingRoot?.unmount();
      managerContainer.remove();
      floatingBallContainer.remove();
    });
  },
});

// 处理消息
function handleMessage(message: any): void {
  switch (message.type) {
    case MessageType.TRANSLATE_PAGE:
      document.dispatchEvent(new CustomEvent('translate-page'));
      break;
      
    case MessageType.TOGGLE_TRANSLATE:
      document.dispatchEvent(new CustomEvent('toggle-translate'));
      break;
      
    case MessageType.SETTINGS_CHANGED:
      document.dispatchEvent(new CustomEvent('settings-changed', {
        detail: message.payload,
      }));
      break;
  }
}

// 悬浮球样式
function getFloatingBallStyles(): string {
  return `
    .floating-ball {
      position: fixed;
      right: 20px;
      bottom: 20px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s, box-shadow 0.2s;
      z-index: 2147483647;
    }
    
    .floating-ball:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(102, 126, 234, 0.5);
    }
    
    .floating-ball.active {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }
    
    .floating-ball svg {
      width: 24px;
      height: 24px;
      fill: white;
    }
    
    .floating-menu {
      position: fixed;
      right: 20px;
      bottom: 80px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      padding: 8px 0;
      min-width: 160px;
      z-index: 2147483646;
    }
    
    .floating-menu-item {
      padding: 10px 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      color: #333;
      transition: background 0.2s;
    }
    
    .floating-menu-item:hover {
      background: #f5f5f5;
    }
    
    .floating-menu-item svg {
      width: 18px;
      height: 18px;
      fill: #666;
    }
  `;
}
```

## 3.3 文本提取工具

### src/utils/dom.ts

```typescript
import type { TextNode } from '@/types/translate';

// 需要跳过的标签
const SKIP_TAGS = new Set([
  'SCRIPT',
  'STYLE',
  'NOSCRIPT',
  'IFRAME',
  'OBJECT',
  'EMBED',
  'AUDIO',
  'VIDEO',
  'CANVAS',
  'SVG',
  'MATH',
  'CODE',
  'PRE',
  'TEXTAREA',
  'INPUT',
  'SELECT',
  'BUTTON',
]);

// 内联标签(不断句)
const INLINE_TAGS = new Set([
  'A',
  'ABBR',
  'B',
  'BDO',
  'BIG',
  'CITE',
  'DFN',
  'EM',
  'I',
  'KBD',
  'LABEL',
  'Q',
  'SAMP',
  'SMALL',
  'SPAN',
  'STRONG',
  'SUB',
  'SUP',
  'TT',
  'VAR',
]);

// 判断是否应该跳过
export function shouldSkipElement(element: Element): boolean {
  // 跳过指定标签
  if (SKIP_TAGS.has(element.tagName)) {
    return true;
  }
  
  // 跳过隐藏元素
  const style = window.getComputedStyle(element);
  if (style.display === 'none' || style.visibility === 'hidden') {
    return true;
  }
  
  // 跳过编辑器区域
  if (element.getAttribute('contenteditable') === 'true') {
    return true;
  }
  
  // 跳过我们自己的元素
  if (element.id?.startsWith('immersive-translate')) {
    return true;
  }
  
  return false;
}

// 判断是否是块级元素
export function isBlockElement(element: Element): boolean {
  return !INLINE_TAGS.has(element.tagName);
}

// 提取页面文本节点
export function extractTextNodes(root: Element = document.body): TextNode[] {
  const textNodes: TextNode[] = [];
  let nodeId = 0;
  
  function walk(node: Node, parentElement: HTMLElement): void {
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent?.trim();
      
      if (text && text.length > 0 && isValidText(text)) {
        const range = document.createRange();
        range.selectNodeContents(node);
        const rect = range.getBoundingClientRect();
        
        // 只处理可见的文本
        if (rect.width > 0 && rect.height > 0) {
          textNodes.push({
            id: `text-${nodeId++}`,
            element: parentElement,
            originalText: text,
            isTranslated: false,
            rect,
          });
        }
      }
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      const element = node as HTMLElement;
      
      if (!shouldSkipElement(element)) {
        for (const child of element.childNodes) {
          walk(child, element);
        }
      }
    }
  }
  
  walk(root, root as HTMLElement);
  return textNodes;
}

// 验证文本是否需要翻译
export function isValidText(text: string): boolean {
  // 至少包含2个字符
  if (text.length < 2) return false;
  
  // 不是纯数字
  if (/^\d+$/.test(text)) return false;
  
  // 不是纯符号
  if (/^[\s\p{P}]+$/u.test(text)) return false;
  
  // 不是 URL
  if (/^https?:\/\//.test(text)) return false;
  
  // 不是邮箱
  if (/^[\w.-]+@[\w.-]+\.\w+$/.test(text)) return false;
  
  return true;
}

// 按段落合并文本节点
export function mergeTextNodes(nodes: TextNode[]): TextNode[][] {
  const paragraphs: TextNode[][] = [];
  let currentParagraph: TextNode[] = [];
  
  for (const node of nodes) {
    const parent = node.element.parentElement;
    
    if (currentParagraph.length === 0) {
      currentParagraph.push(node);
    } else {
      const lastNode = currentParagraph[currentParagraph.length - 1];
      const lastParent = lastNode.element.parentElement;
      
      // 如果在同一个块级容器内,合并
      if (parent === lastParent || isInSameBlock(lastNode.element, node.element)) {
        currentParagraph.push(node);
      } else {
        paragraphs.push(currentParagraph);
        currentParagraph = [node];
      }
    }
  }
  
  if (currentParagraph.length > 0) {
    paragraphs.push(currentParagraph);
  }
  
  return paragraphs;
}

// 判断两个元素是否在同一个块中
function isInSameBlock(el1: HTMLElement, el2: HTMLElement): boolean {
  const block1 = findParentBlock(el1);
  const block2 = findParentBlock(el2);
  return block1 === block2;
}

// 查找最近的块级父元素
function findParentBlock(element: HTMLElement): HTMLElement | null {
  let current: HTMLElement | null = element;
  
  while (current && current !== document.body) {
    if (isBlockElement(current)) {
      return current;
    }
    current = current.parentElement;
  }
  
  return null;
}

// 创建翻译结果容器
export function createTranslateContainer(
  targetElement: HTMLElement,
  translatedText: string,
  mode: 'bilingual' | 'replace' = 'bilingual'
): HTMLElement {
  const container = document.createElement('div');
  container.className = 'immersive-translate-result';
  container.setAttribute('data-translate-id', targetElement.getAttribute('data-translate-id') || '');
  
  if (mode === 'bilingual') {
    container.innerHTML = `
      <div class="translate-original">${escapeHtml(targetElement.textContent || '')}</div>
      <div class="translate-divider"></div>
      <div class="translate-text">${escapeHtml(translatedText)}</div>
    `;
  } else {
    container.innerHTML = `
      <div class="translate-text">${escapeHtml(translatedText)}</div>
    `;
  }
  
  return container;
}

// HTML 转义
function escapeHtml(text: string): string {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}
```

### src/utils/text.ts

```typescript
// 分割长文本
export function splitText(text: string, maxLength: number = 5000): string[] {
  if (text.length <= maxLength) {
    return [text];
  }
  
  const chunks: string[] = [];
  const sentences = text.split(/(?<=[.!?。！？\n])\s*/);
  let currentChunk = '';
  
  for (const sentence of sentences) {
    if (currentChunk.length + sentence.length > maxLength) {
      if (currentChunk) {
        chunks.push(currentChunk.trim());
      }
      
      // 如果单个句子超长,强制分割
      if (sentence.length > maxLength) {
        const words = sentence.split(/\s+/);
        currentChunk = '';
        
        for (const word of words) {
          if (currentChunk.length + word.length > maxLength) {
            chunks.push(currentChunk.trim());
            currentChunk = word + ' ';
          } else {
            currentChunk += word + ' ';
          }
        }
      } else {
        currentChunk = sentence + ' ';
      }
    } else {
      currentChunk += sentence + ' ';
    }
  }
  
  if (currentChunk.trim()) {
    chunks.push(currentChunk.trim());
  }
  
  return chunks;
}

// 检测文本语言
export function detectLanguage(text: string): string {
  // 中文检测
  const chineseCount = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
  // 日文检测
  const japaneseCount = (text.match(/[\u3040-\u309f\u30a0-\u30ff]/g) || []).length;
  // 韩文检测
  const koreanCount = (text.match(/[\uac00-\ud7af]/g) || []).length;
  
  const totalLength = text.length;
  
  if (chineseCount / totalLength > 0.3) return 'zh-CN';
  if (japaneseCount / totalLength > 0.1) return 'ja';
  if (koreanCount / totalLength > 0.3) return 'ko';
  
  // 默认英语
  return 'en';
}

// 判断文本是否需要翻译(不是目标语言)
export function needsTranslation(text: string, targetLang: string): boolean {
  const sourceLang = detectLanguage(text);
  
  // 如果源语言和目标语言相同,不需要翻译
  if (sourceLang === targetLang) return false;
  
  // 如果是简繁体转换
  if (
    (sourceLang === 'zh-CN' && targetLang === 'zh-TW') ||
    (sourceLang === 'zh-TW' && targetLang === 'zh-CN')
  ) {
    return true;
  }
  
  return true;
}

// 标准化文本(去除多余空白)
export function normalizeText(text: string): string {
  return text
    .replace(/\s+/g, ' ')
    .replace(/\n\s*\n/g, '\n')
    .trim();
}

// 计算文本相似度(用于判断是否已翻译)
export function textSimilarity(text1: string, text2: string): number {
  const s1 = text1.toLowerCase();
  const s2 = text2.toLowerCase();
  
  if (s1 === s2) return 1;
  
  const longer = s1.length > s2.length ? s1 : s2;
  const shorter = s1.length > s2.length ? s2 : s1;
  
  if (longer.length === 0) return 1;
  
  const editDistance = levenshteinDistance(longer, shorter);
  return (longer.length - editDistance) / longer.length;
}

// Levenshtein 距离
function levenshteinDistance(s1: string, s2: string): number {
  const m = s1.length;
  const n = s2.length;
  
  const dp: number[][] = Array(m + 1)
    .fill(null)
    .map(() => Array(n + 1).fill(0));
  
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (s1[i - 1] === s2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
      }
    }
  }
  
  return dp[m][n];
}
```

## 3.4 翻译管理器组件

### src/components/translate/TranslateManager.tsx

```tsx
import React, { useEffect, useState, useCallback, useRef } from 'react';
import { sendToBackground } from '@/services/messaging';
import { MessageType } from '@/types/message';
import type { TextNode, TranslateResult } from '@/types/translate';
import type { UserSettings } from '@/types/settings';
import { extractTextNodes, mergeTextNodes } from '@/utils/dom';
import { needsTranslation, normalizeText } from '@/utils/text';
import { settingsStorage } from '@/stores/storage';
import { BilingualText } from './BilingualText';

interface TranslateState {
  isTranslating: boolean;
  progress: number;
  totalNodes: number;
  translatedNodes: Map<string, TranslateResult>;
}

export const TranslateManager: React.FC = () => {
  const [settings, setSettings] = useState<UserSettings | null>(null);
  const [state, setState] = useState<TranslateState>({
    isTranslating: false,
    progress: 0,
    totalNodes: 0,
    translatedNodes: new Map(),
  });
  
  const textNodesRef = useRef<TextNode[]>([]);
  const observerRef = useRef<MutationObserver | null>(null);
  
  // 加载设置
  useEffect(() => {
    settingsStorage.getValue().then(setSettings);
    
    // 监听设置变化
    const handleSettingsChange = (event: CustomEvent<UserSettings>) => {
      setSettings(event.detail);
    };
    
    document.addEventListener('settings-changed', handleSettingsChange as EventListener);
    
    return () => {
      document.removeEventListener('settings-changed', handleSettingsChange as EventListener);
    };
  }, []);
  
  // 翻译单个文本
  const translateText = useCallback(async (text: string): Promise<TranslateResult | null> => {
    if (!settings) return null;
    
    const response = await sendToBackground<TranslateResult>({
      type: MessageType.TRANSLATE_TEXT,
      timestamp: Date.now(),
      payload: {
        text: normalizeText(text),
        from: settings.sourceLanguage,
        to: settings.targetLanguage,
      },
    });
    
    if (response.success && response.data) {
      return response.data;
    }
    
    return null;
  }, [settings]);
  
  // 翻译整个页面
  const translatePage = useCallback(async () => {
    if (!settings || state.isTranslating) return;
    
    console.log('[TranslateManager] Starting page translation');
    
    // 提取文本节点
    const nodes = extractTextNodes();
    textNodesRef.current = nodes;
    
    // 过滤需要翻译的节点
    const nodesToTranslate = nodes.filter((node) =>
      needsTranslation(node.originalText, settings.targetLanguage)
    );
    
    setState((prev) => ({
      ...prev,
      isTranslating: true,
      progress: 0,
      totalNodes: nodesToTranslate.length,
    }));
    
    // 按段落合并
    const paragraphs = mergeTextNodes(nodesToTranslate);
    
    // 批量翻译
    let translatedCount = 0;
    const newTranslatedNodes = new Map(state.translatedNodes);
    
    for (const paragraph of paragraphs) {
      // 合并段落文本
      const paragraphText = paragraph.map((n) => n.originalText).join(' ');
      
      try {
        const result = await translateText(paragraphText);
        
        if (result) {
          // 为每个节点设置翻译结果
          for (const node of paragraph) {
            newTranslatedNodes.set(node.id, {
              ...result,
              originalText: node.originalText,
            });
            
            // 标记元素已翻译
            node.element.setAttribute('data-translate-id', node.id);
            node.isTranslated = true;
          }
          
          translatedCount += paragraph.length;
          
          setState((prev) => ({
            ...prev,
            progress: translatedCount,
            translatedNodes: new Map(newTranslatedNodes),
          }));
        }
      } catch (error) {
        console.error('[TranslateManager] Translation error:', error);
      }
      
      // 添加延迟避免请求过快
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
    
    setState((prev) => ({
      ...prev,
      isTranslating: false,
    }));
    
    console.log('[TranslateManager] Page translation complete');
  }, [settings, state.isTranslating, translateText]);
  
  // 监听翻译事件
  useEffect(() => {
    const handleTranslatePage = () => translatePage();
    const handleToggleTranslate = () => {
      if (state.translatedNodes.size > 0) {
        // 清除翻译
        setState((prev) => ({
          ...prev,
          translatedNodes: new Map(),
        }));
      } else {
        translatePage();
      }
    };
    
    document.addEventListener('translate-page', handleTranslatePage);
    document.addEventListener('toggle-translate', handleToggleTranslate);
    
    return () => {
      document.removeEventListener('translate-page', handleTranslatePage);
      document.removeEventListener('toggle-translate', handleToggleTranslate);
    };
  }, [translatePage, state.translatedNodes.size]);
  
  // 监听 DOM 变化(用于动态内容)
  useEffect(() => {
    if (!settings?.triggerMode === 'auto') return;
    
    observerRef.current = new MutationObserver((mutations) => {
      // 检测新增的文本内容
      for (const mutation of mutations) {
        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
          // 延迟处理,等待 DOM 稳定
          setTimeout(() => {
            // 这里可以实现增量翻译
          }, 500);
        }
      }
    });
    
    observerRef.current.observe(document.body, {
      childList: true,
      subtree: true,
    });
    
    return () => {
      observerRef.current?.disconnect();
    };
  }, [settings?.triggerMode]);
  
  // 渲染翻译结果
  return (
    <>
      {/* 进度条 */}
      {state.isTranslating && (
        <div className="immersive-translate-progress">
          <div 
            className="immersive-translate-progress-bar"
            style={{ 
              width: `${(state.progress / state.totalNodes) * 100}%` 
            }}
          />
          <span className="immersive-translate-progress-text">
            {state.progress} / {state.totalNodes}
          </span>
        </div>
      )}
      
      {/* 双语显示 */}
      {settings?.translateMode === 'bilingual' && (
        Array.from(state.translatedNodes.entries()).map(([id, result]) => (
          <BilingualText
            key={id}
            nodeId={id}
            original={result.originalText}
            translated={result.translatedText}
            settings={settings}
          />
        ))
      )}
    </>
  );
};
```

### src/components/translate/BilingualText.tsx

```tsx
import React, { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import type { UserSettings } from '@/types/settings';

interface BilingualTextProps {
  nodeId: string;
  original: string;
  translated: string;
  settings: UserSettings;
}

export const BilingualText: React.FC<BilingualTextProps> = ({
  nodeId,
  original,
  translated,
  settings,
}) => {
  const containerRef = useRef<HTMLDivElement | null>(null);
  
  useEffect(() => {
    // 查找对应的元素
    const targetElement = document.querySelector(`[data-translate-id="${nodeId}"]`);
    
    if (!targetElement) return;
    
    // 创建翻译容器
    const container = document.createElement('div');
    container.className = 'immersive-translate-inline';
    containerRef.current = container;
    
    // 设置样式
    container.style.cssText = `
      display: block;
      font-size: ${settings.fontSize}px;
      line-height: 1.6;
      margin-top: 4px;
      padding: 4px 8px;
      background: rgba(102, 126, 234, 0.1);
      border-left: 3px solid #667eea;
      border-radius: 0 4px 4px 0;
      color: #333;
    `;
    
    // 显示原文(可选)
    if (settings.showOriginal) {
      const originalSpan = document.createElement('span');
      originalSpan.className = 'translate-original';
      originalSpan.style.cssText = `
        display: block;
        color: #666;
        font-size: ${settings.fontSize - 1}px;
        text-decoration: line-through;
        opacity: 0.7;
      `;
      originalSpan.textContent = original;
      container.appendChild(originalSpan);
    }
    
    // 显示译文
    const translatedSpan = document.createElement('span');
    translatedSpan.className = 'translate-text';
    translatedSpan.textContent = translated;
    container.appendChild(translatedSpan);
    
    // 插入到目标元素后面
    targetElement.parentNode?.insertBefore(container, targetElement.nextSibling);
    
    // 高亮原文(可选)
    if (settings.highlightTranslated) {
      (targetElement as HTMLElement).style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
    }
    
    return () => {
      container.remove();
      if (settings.highlightTranslated) {
        (targetElement as HTMLElement).style.backgroundColor = '';
      }
    };
  }, [nodeId, original, translated, settings]);
  
  return null;
};
```

## 3.5 悬浮球组件

### src/components/translate/FloatingBall.tsx

```tsx
import React, { useState, useCallback, useEffect } from 'react';
import { settingsStorage } from '@/stores/storage';
import type { UserSettings } from '@/types/settings';

export const FloatingBall: React.FC = () => {
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [isActive, setIsActive] = useState(false);
  const [settings, setSettings] = useState<UserSettings | null>(null);
  const [position, setPosition] = useState({ x: 20, y: 20 });
  const [isDragging, setIsDragging] = useState(false);
  
  // 加载设置
  useEffect(() => {
    settingsStorage.getValue().then(setSettings);
  }, []);
  
  // 切换翻译
  const handleToggle = useCallback(() => {
    setIsActive((prev) => !prev);
    document.dispatchEvent(new CustomEvent('toggle-translate'));
    setIsMenuOpen(false);
  }, []);
  
  // 翻译整页
  const handleTranslatePage = useCallback(() => {
    document.dispatchEvent(new CustomEvent('translate-page'));
    setIsActive(true);
    setIsMenuOpen(false);
  }, []);
  
  // 打开设置
  const handleOpenSettings = useCallback(() => {
    browser.runtime.sendMessage({ type: 'OPEN_OPTIONS' });
    setIsMenuOpen(false);
  }, []);
  
  // 拖拽处理
  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (e.button !== 0) return;
    setIsDragging(true);
  }, []);
  
  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      if (!isDragging) return;
      
      setPosition({
        x: window.innerWidth - e.clientX - 24,
        y: window.innerHeight - e.clientY - 24,
      });
    },
    [isDragging]
  );
  
  const handleMouseUp = useCallback(() => {
    setIsDragging(false);
  }, []);
  
  useEffect(() => {
    if (isDragging) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    }
    
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDragging, handleMouseMove, handleMouseUp]);
  
  if (!settings?.enabled) return null;
  
  return (
    <>
      {/* 悬浮球 */}
      <div
        className={`floating-ball ${isActive ? 'active' : ''}`}
        style={{
          right: position.x,
          bottom: position.y,
        }}
        onClick={() => !isDragging && setIsMenuOpen((prev) => !prev)}
        onMouseDown={handleMouseDown}
      >
        <svg viewBox="0 0 24 24">
          <path d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"/>
        </svg>
      </div>
      
      {/* 菜单 */}
      {isMenuOpen && (
        <div
          className="floating-menu"
          style={{
            right: position.x,
            bottom: position.y + 60,
          }}
        >
          <div className="floating-menu-item" onClick={handleToggle}>
            <svg viewBox="0 0 24 24">
              <path d={isActive 
                ? "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
                : "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"
              }/>
            </svg>
            <span>{isActive ? '关闭翻译' : '开启翻译'}</span>
          </div>
          
          <div className="floating-menu-item" onClick={handleTranslatePage}>
            <svg viewBox="0 0 24 24">
              <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
            </svg>
            <span>翻译整页</span>
          </div>
          
          <div className="floating-menu-item" onClick={handleOpenSettings}>
            <svg viewBox="0 0 24 24">
              <path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
            </svg>
            <span>设置</span>
          </div>
        </div>
      )}
    </>
  );
};
```

## 3.6 选中翻译功能

### src/components/translate/SelectionTranslate.tsx

```tsx
import React, { useState, useEffect, useCallback } from 'react';
import { sendToBackground } from '@/services/messaging';
import { MessageType } from '@/types/message';
import type { TranslateResult } from '@/types/translate';
import { settingsStorage } from '@/stores/storage';

interface Position {
  x: number;
  y: number;
}

export const SelectionTranslate: React.FC = () => {
  const [selectedText, setSelectedText] = useState('');
  const [position, setPosition] = useState<Position | null>(null);
  const [result, setResult] = useState<TranslateResult | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  
  // 处理选中事件
  const handleSelection = useCallback(() => {
    const selection = window.getSelection();
    const text = selection?.toString().trim();
    
    if (text && text.length > 0) {
      const range = selection?.getRangeAt(0);
      const rect = range?.getBoundingClientRect();
      
      if (rect) {
        setSelectedText(text);
        setPosition({
          x: rect.left + rect.width / 2,
          y: rect.bottom + window.scrollY + 10,
        });
        setResult(null);
      }
    } else {
      setPosition(null);
      setSelectedText('');
      setResult(null);
    }
  }, []);
  
  // 翻译选中文本
  const handleTranslate = useCallback(async () => {
    if (!selectedText) return;
    
    setIsLoading(true);
    
    try {
      const settings = await settingsStorage.getValue();
      
      const response = await sendToBackground<TranslateResult>({
        type: MessageType.TRANSLATE_TEXT,
        timestamp: Date.now(),
        payload: {
          text: selectedText,
          from: settings.sourceLanguage,
          to: settings.targetLanguage,
        },
      });
      
      if (response.success && response.data) {
        setResult(response.data);
      }
    } catch (error) {
      console.error('[SelectionTranslate] Error:', error);
    } finally {
      setIsLoading(false);
    }
  }, [selectedText]);
  
  // 监听选中事件
  useEffect(() => {
    document.addEventListener('mouseup', handleSelection);
    document.addEventListener('keyup', handleSelection);
    
    return () => {
      document.removeEventListener('mouseup', handleSelection);
      document.removeEventListener('keyup', handleSelection);
    };
  }, [handleSelection]);
  
  // 点击外部关闭
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      const target = e.target as HTMLElement;
      if (!target.closest('.selection-translate-popup')) {
        setPosition(null);
      }
    };
    
    document.addEventListener('click', handleClickOutside);
    return () => document.removeEventListener('click', handleClickOutside);
  }, []);
  
  if (!position) return null;
  
  return (
    <div
      className="selection-translate-popup"
      style={{
        position: 'absolute',
        left: position.x,
        top: position.y,
        transform: 'translateX(-50%)',
        zIndex: 2147483647,
      }}
    >
      {!result ? (
        <button
          className="selection-translate-btn"
          onClick={handleTranslate}
          disabled={isLoading}
        >
          {isLoading ? '翻译中...' : '翻译'}
        </button>
      ) : (
        <div className="selection-translate-result">
          <div className="original">{result.originalText}</div>
          <div className="translated">{result.translatedText}</div>
        </div>
      )}
    </div>
  );
};
```

## 3.7 内容脚本样式

### src/assets/styles/content.css

```css
/* 翻译进度条 */
.immersive-translate-progress {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: #e0e0e0;
  z-index: 2147483647;
}

.immersive-translate-progress-bar {
  height: 100%;
  background: linear-gradient(90deg, #667eea, #764ba2);
  transition: width 0.3s ease;
}

.immersive-translate-progress-text {
  position: absolute;
  right: 10px;
  top: 6px;
  font-size: 12px;
  color: #666;
  background: white;
  padding: 2px 8px;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* 行内翻译结果 */
.immersive-translate-inline {
  display: block;
  font-size: 14px;
  line-height: 1.6;
  margin-top: 4px;
  padding: 4px 8px;
  background: rgba(102, 126, 234, 0.1);
  border-left: 3px solid #667eea;
  border-radius: 0 4px 4px 0;
  color: #333;
}

.immersive-translate-inline .translate-original {
  display: block;
  color: #666;
  font-size: 13px;
  text-decoration: line-through;
  opacity: 0.7;
}

.immersive-translate-inline .translate-text {
  display: block;
  color: #333;
}

/* 选中翻译弹窗 */
.selection-translate-popup {
  background: white;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  padding: 12px;
  min-width: 200px;
  max-width: 400px;
}

.selection-translate-btn {
  display: block;
  width: 100%;
  padding: 8px 16px;
  background: linear-gradient(135deg, #667eea, #764ba2);
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  transition: opacity 0.2s;
}

.selection-translate-btn:hover {
  opacity: 0.9;
}

.selection-translate-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.selection-translate-result {
  font-size: 14px;
  line-height: 1.6;
}

.selection-translate-result .original {
  color: #666;
  margin-bottom: 8px;
  padding-bottom: 8px;
  border-bottom: 1px solid #eee;
}

.selection-translate-result .translated {
  color: #333;
}
```

## 3.8 本章小结

本章实现了内容脚本的核心功能:

1. **文本提取**: 智能识别页面中需要翻译的文本
2. **翻译管理器**: 协调翻译请求和结果展示
3. **双语显示**: 在原文旁边展示译文
4. **悬浮球**: 提供便捷的操作入口
5. **选中翻译**: 选中文本快速翻译

下一章我们将实现 Popup 弹出页面和 Options 设置页面。
