# 沉浸式翻译插件 - 国际化与自动导入集成

## 概述

本章节将为沉浸式翻译插件添加完整的国际化(i18n)支持和自动导入系统,使插件能够支持多语言界面,并优化开发体验。

## 1. 国际化系统集成

### 1.1 安装 i18n 模块

```bash
pnpm add @wxt-dev/i18n
```

### 1.2 配置 WXT

```typescript
// wxt.config.ts
import { defineConfig } from 'wxt';

export default defineConfig({
  modules: ['@wxt-dev/i18n/module'],
  manifest: {
    default_locale: 'en',
    name: '__MSG_extName__',
    description: '__MSG_extDescription__',
  },
});
```

### 1.3 创建语言文件

```yaml
# src/locales/en.yml
extName: Immersive Translator
extDescription: Translate web pages with immersive bilingual reading experience

# 通用
common:
  settings: Settings
  save: Save
  cancel: Cancel
  loading: Loading...
  error: Error
  success: Success

# Popup 页面
popup:
  title: Immersive Translator
  translatePage: Translate This Page
  originalMode: Original
  bilingualMode: Bilingual
  translateMode: Translation Only
  settings: Settings
  
# 翻译相关
translation:
  translating: Translating...
  translateSuccess: Translation completed
  translateFailed: Translation failed
  noContent: No content to translate
  selectText: Select text to translate
  
# 设置页面
settings:
  title: Settings
  general: General
  translation: Translation
  appearance: Appearance
  shortcuts: Shortcuts
  about: About
  
  # 翻译设置
  translationService: Translation Service
  targetLanguage: Target Language
  sourceLanguage: Source Language (Auto-detect)
  apiKey: API Key
  apiKeyPlaceholder: Enter your API key
  
  # 外观设置
  theme: Theme
  themeLight: Light
  themeDark: Dark
  themeSystem: Follow System
  fontSize: Font Size
  
  # 会员相关
  membership: Membership
  membershipStatus: Membership Status
  membershipFree: Free
  membershipPro: Pro Member
  membershipExpires: Expires on
  upgradeToPro: Upgrade to Pro

# 快捷键
shortcuts:
  translatePage: Translate Page
  toggleMode: Toggle Display Mode
  translateSelection: Translate Selection
```

```yaml
# src/locales/zh-CN.yml
extName: 沉浸式翻译
extDescription: 沉浸式双语网页翻译体验

common:
  settings: 设置
  save: 保存
  cancel: 取消
  loading: 加载中...
  error: 错误
  success: 成功

popup:
  title: 沉浸式翻译
  translatePage: 翻译此页面
  originalMode: 原文
  bilingualMode: 双语
  translateMode: 仅译文
  settings: 设置

translation:
  translating: 翻译中...
  translateSuccess: 翻译完成
  translateFailed: 翻译失败
  noContent: 没有可翻译的内容
  selectText: 选择要翻译的文本

settings:
  title: 设置
  general: 通用
  translation: 翻译
  appearance: 外观
  shortcuts: 快捷键
  about: 关于
  
  translationService: 翻译服务
  targetLanguage: 目标语言
  sourceLanguage: 源语言 (自动检测)
  apiKey: API 密钥
  apiKeyPlaceholder: 请输入您的 API 密钥
  
  theme: 主题
  themeLight: 浅色
  themeDark: 深色
  themeSystem: 跟随系统
  fontSize: 字体大小
  
  membership: 会员
  membershipStatus: 会员状态
  membershipFree: 免费版
  membershipPro: Pro 会员
  membershipExpires: 到期时间
  upgradeToPro: 升级为 Pro

shortcuts:
  translatePage: 翻译页面
  toggleMode: 切换显示模式
  translateSelection: 翻译选中文本
```

```yaml
# src/locales/ja.yml
extName: イマーシブ翻訳
extDescription: 没入型バイリンガルウェブページ翻訳体験

common:
  settings: 設定
  save: 保存
  cancel: キャンセル
  loading: 読み込み中...
  error: エラー
  success: 成功

popup:
  title: イマーシブ翻訳
  translatePage: このページを翻訳
  originalMode: 原文
  bilingualMode: バイリンガル
  translateMode: 翻訳のみ
  settings: 設定

translation:
  translating: 翻訳中...
  translateSuccess: 翻訳完了
  translateFailed: 翻訳失敗
  noContent: 翻訳するコンテンツがありません
  selectText: 翻訳するテキストを選択

settings:
  title: 設定
  general: 一般
  translation: 翻訳
  appearance: 外観
  shortcuts: ショートカット
  about: について
  
  translationService: 翻訳サービス
  targetLanguage: 翻訳先言語
  sourceLanguage: 翻訳元言語 (自動検出)
  apiKey: APIキー
  apiKeyPlaceholder: APIキーを入力してください
  
  theme: テーマ
  themeLight: ライト
  themeDark: ダーク
  themeSystem: システムに従う
  fontSize: フォントサイズ
  
  membership: メンバーシップ
  membershipStatus: メンバーシップ状態
  membershipFree: 無料
  membershipPro: Proメンバー
  membershipExpires: 有効期限
  upgradeToPro: Proにアップグレード

shortcuts:
  translatePage: ページを翻訳
  toggleMode: 表示モード切替
  translateSelection: 選択テキストを翻訳
```

### 1.4 使用 i18n

```typescript
// src/utils/i18n.ts
import { createI18n } from '@wxt-dev/i18n';

export const i18n = createI18n();

// 导出便捷函数
export const t = i18n.t.bind(i18n);
```

```tsx
// entrypoints/popup/App.tsx
import React, { useState } from 'react';
import { t } from '@/utils/i18n';

export default function App() {
  const [mode, setMode] = useState<'original' | 'bilingual' | 'translate'>('bilingual');

  const handleTranslate = async () => {
    const [tab] = await browser.tabs.query({ active: true, currentWindow: true });
    if (tab.id) {
      await browser.tabs.sendMessage(tab.id, { action: 'translate' });
    }
  };

  return (
    <div className="popup-container">
      <h1 className="popup-title">{t('popup.title')}</h1>
      
      <button onClick={handleTranslate} className="translate-btn">
        {t('popup.translatePage')}
      </button>
      
      <div className="mode-selector">
        <button 
          className={mode === 'original' ? 'active' : ''}
          onClick={() => setMode('original')}
        >
          {t('popup.originalMode')}
        </button>
        <button 
          className={mode === 'bilingual' ? 'active' : ''}
          onClick={() => setMode('bilingual')}
        >
          {t('popup.bilingualMode')}
        </button>
        <button 
          className={mode === 'translate' ? 'active' : ''}
          onClick={() => setMode('translate')}
        >
          {t('popup.translateMode')}
        </button>
      </div>
      
      <a href="/options.html" className="settings-link">
        {t('popup.settings')}
      </a>
    </div>
  );
}
```

### 1.5 动态语言切换

```typescript
// src/utils/language.ts
import { storage } from 'wxt/storage';

export const languageStorage = storage.defineItem<string>('local:language', {
  fallback: 'en',
});

export async function setLanguage(lang: string) {
  await languageStorage.setValue(lang);
  // 通知所有页面更新语言
  browser.runtime.sendMessage({ action: 'languageChanged', lang });
}

export async function getLanguage(): Promise<string> {
  const stored = await languageStorage.getValue();
  if (stored) return stored;
  
  // 检测浏览器语言
  const browserLang = browser.i18n.getUILanguage();
  if (browserLang.startsWith('zh')) return 'zh-CN';
  if (browserLang.startsWith('ja')) return 'ja';
  return 'en';
}
```

## 2. 自动导入系统配置

### 2.1 配置自动导入

```typescript
// wxt.config.ts
import { defineConfig } from 'wxt';

export default defineConfig({
  modules: ['@wxt-dev/i18n/module'],
  imports: {
    // 添加自定义导入预设
    presets: [
      // React hooks
      {
        from: 'react',
        imports: ['useState', 'useEffect', 'useCallback', 'useMemo', 'useRef'],
      },
    ],
    // 自动导入目录
    dirs: [
      'src/composables',
      'src/utils',
      'src/hooks',
    ],
    // ESLint 集成
    eslintrc: {
      enabled: true,
    },
  },
});
```

### 2.2 创建可复用 Hooks

```typescript
// src/hooks/useTranslation.ts
import { useState, useCallback } from 'react';
import { translateText } from '@/services/translator';
import type { TranslationResult } from '@/types';

export function useTranslation() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [result, setResult] = useState<TranslationResult | null>(null);

  const translate = useCallback(async (text: string, targetLang: string) => {
    setLoading(true);
    setError(null);
    
    try {
      const translated = await translateText(text, targetLang);
      setResult(translated);
      return translated;
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Translation failed';
      setError(message);
      throw e;
    } finally {
      setLoading(false);
    }
  }, []);

  const reset = useCallback(() => {
    setResult(null);
    setError(null);
  }, []);

  return { translate, loading, error, result, reset };
}
```

```typescript
// src/hooks/useStorage.ts
import { useState, useEffect, useCallback } from 'react';
import { storage } from 'wxt/storage';

export function useStorage<T>(key: string, defaultValue: T) {
  const [value, setValue] = useState<T>(defaultValue);
  const [loading, setLoading] = useState(true);

  const storageItem = storage.defineItem<T>(`local:${key}`, {
    fallback: defaultValue,
  });

  useEffect(() => {
    // 初始加载
    storageItem.getValue().then((stored) => {
      setValue(stored);
      setLoading(false);
    });

    // 监听变化
    const unwatch = storageItem.watch((newValue) => {
      setValue(newValue);
    });

    return unwatch;
  }, [key]);

  const updateValue = useCallback(async (newValue: T | ((prev: T) => T)) => {
    const resolvedValue = typeof newValue === 'function' 
      ? (newValue as (prev: T) => T)(value)
      : newValue;
    
    await storageItem.setValue(resolvedValue);
    setValue(resolvedValue);
  }, [value]);

  return [value, updateValue, loading] as const;
}
```

```typescript
// src/hooks/useMembership.ts
import { useState, useEffect } from 'react';
import { membershipStorage } from '@/storage/membership';
import type { MembershipInfo } from '@/types';

export function useMembership() {
  const [membership, setMembership] = useState<MembershipInfo | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    membershipStorage.getValue().then((info) => {
      setMembership(info);
      setLoading(false);
    });

    const unwatch = membershipStorage.watch((newInfo) => {
      setMembership(newInfo);
    });

    return unwatch;
  }, []);

  const isPro = membership?.type === 'pro' && 
    (!membership.expiresAt || new Date(membership.expiresAt) > new Date());

  const refresh = async () => {
    setLoading(true);
    try {
      // 从服务器获取最新会员状态
      const response = await fetch(`${API_BASE_URL}/api/membership/status`, {
        credentials: 'include',
      });
      if (response.ok) {
        const data = await response.json();
        await membershipStorage.setValue(data);
        setMembership(data);
      }
    } finally {
      setLoading(false);
    }
  };

  return { membership, isPro, loading, refresh };
}
```

### 2.3 创建工具函数

```typescript
// src/utils/dom.ts
/**
 * 获取页面中所有可翻译的文本节点
 */
export function getTranslatableNodes(root: Element = document.body): Text[] {
  const walker = document.createTreeWalker(
    root,
    NodeFilter.SHOW_TEXT,
    {
      acceptNode: (node) => {
        const parent = node.parentElement;
        if (!parent) return NodeFilter.FILTER_REJECT;
        
        // 排除脚本、样式等
        const tag = parent.tagName.toLowerCase();
        if (['script', 'style', 'noscript', 'code', 'pre'].includes(tag)) {
          return NodeFilter.FILTER_REJECT;
        }
        
        // 排除空白文本
        if (!node.textContent?.trim()) {
          return NodeFilter.FILTER_REJECT;
        }
        
        // 排除已翻译的元素
        if (parent.closest('[data-translated]')) {
          return NodeFilter.FILTER_REJECT;
        }
        
        return NodeFilter.FILTER_ACCEPT;
      },
    }
  );

  const nodes: Text[] = [];
  let node: Text | null;
  while ((node = walker.nextNode() as Text | null)) {
    nodes.push(node);
  }
  return nodes;
}

/**
 * 创建双语显示元素
 */
export function createBilingualElement(
  original: string,
  translated: string,
  options?: { showOriginal?: boolean }
): HTMLElement {
  const container = document.createElement('span');
  container.className = 'immersive-translate-container';
  container.setAttribute('data-translated', 'true');
  
  if (options?.showOriginal !== false) {
    const originalSpan = document.createElement('span');
    originalSpan.className = 'immersive-translate-original';
    originalSpan.textContent = original;
    container.appendChild(originalSpan);
  }
  
  const translatedSpan = document.createElement('span');
  translatedSpan.className = 'immersive-translate-result';
  translatedSpan.textContent = translated;
  container.appendChild(translatedSpan);
  
  return container;
}

/**
 * 批量处理文本节点
 */
export async function batchProcess<T, R>(
  items: T[],
  processor: (batch: T[]) => Promise<R[]>,
  batchSize: number = 50
): Promise<R[]> {
  const results: R[] = [];
  
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    const batchResults = await processor(batch);
    results.push(...batchResults);
  }
  
  return results;
}
```

```typescript
// src/utils/api.ts
import { settingsStorage } from '@/storage/settings';
import { membershipStorage } from '@/storage/membership';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'https://api.immersive-translator.com';

interface RequestOptions extends RequestInit {
  requireAuth?: boolean;
}

/**
 * 封装 API 请求
 */
export async function apiRequest<T>(
  endpoint: string,
  options: RequestOptions = {}
): Promise<T> {
  const { requireAuth = false, ...fetchOptions } = options;
  
  const headers = new Headers(fetchOptions.headers);
  headers.set('Content-Type', 'application/json');
  
  if (requireAuth) {
    const membership = await membershipStorage.getValue();
    if (membership?.token) {
      headers.set('Authorization', `Bearer ${membership.token}`);
    }
  }
  
  const response = await fetch(`${API_BASE_URL}${endpoint}`, {
    ...fetchOptions,
    headers,
    credentials: 'include',
  });
  
  if (!response.ok) {
    const error = await response.json().catch(() => ({ message: 'Request failed' }));
    throw new Error(error.message || `HTTP ${response.status}`);
  }
  
  return response.json();
}

/**
 * 检查是否需要 API Key
 */
export async function needsApiKey(): Promise<boolean> {
  const membership = await membershipStorage.getValue();
  // Pro 会员不需要自己的 API Key
  if (membership?.type === 'pro') {
    const expiresAt = membership.expiresAt ? new Date(membership.expiresAt) : null;
    if (!expiresAt || expiresAt > new Date()) {
      return false;
    }
  }
  return true;
}
```

## 3. 集成到内容脚本

```typescript
// entrypoints/content/index.ts
import { defineContentScript } from 'wxt/sandbox';
import { t } from '@/utils/i18n';
import { getTranslatableNodes, createBilingualElement, batchProcess } from '@/utils/dom';
import { translateBatch } from '@/services/translator';
import { settingsStorage } from '@/storage/settings';

export default defineContentScript({
  matches: ['<all_urls>'],
  cssInjectionMode: 'ui',
  
  async main(ctx) {
    console.log(t('translation.translating'));
    
    // 监听翻译请求
    browser.runtime.onMessage.addListener(async (message) => {
      if (message.action === 'translate') {
        await translatePage();
        return { success: true };
      }
      
      if (message.action === 'setMode') {
        setDisplayMode(message.mode);
        return { success: true };
      }
    });
    
    async function translatePage() {
      const settings = await settingsStorage.getValue();
      const nodes = getTranslatableNodes();
      
      if (nodes.length === 0) {
        console.log(t('translation.noContent'));
        return;
      }
      
      // 提取文本
      const texts = nodes.map(node => node.textContent || '');
      
      // 批量翻译
      const translations = await batchProcess(
        texts,
        async (batch) => translateBatch(batch, settings.targetLanguage),
        20 // 每批20条
      );
      
      // 替换DOM
      nodes.forEach((node, index) => {
        const original = texts[index];
        const translated = translations[index];
        
        if (translated && translated !== original) {
          const container = createBilingualElement(original, translated, {
            showOriginal: settings.displayMode !== 'translate',
          });
          node.parentElement?.replaceChild(container, node);
        }
      });
      
      console.log(t('translation.translateSuccess'));
    }
    
    function setDisplayMode(mode: 'original' | 'bilingual' | 'translate') {
      const containers = document.querySelectorAll('.immersive-translate-container');
      
      containers.forEach((container) => {
        const original = container.querySelector('.immersive-translate-original');
        const translated = container.querySelector('.immersive-translate-result');
        
        if (original instanceof HTMLElement) {
          original.style.display = mode === 'translate' ? 'none' : '';
        }
        if (translated instanceof HTMLElement) {
          translated.style.display = mode === 'original' ? 'none' : '';
        }
      });
    }
  },
});
```

## 4. 内容脚本样式

```css
/* entrypoints/content/style.css */
.immersive-translate-container {
  display: inline;
}

.immersive-translate-original {
  display: inline;
}

.immersive-translate-result {
  display: block;
  color: var(--immersive-translate-color, #1a73e8);
  font-size: var(--immersive-translate-font-size, 0.95em);
  margin-top: 4px;
  padding: 2px 0;
  border-left: 2px solid var(--immersive-translate-color, #1a73e8);
  padding-left: 8px;
}

/* 暗色模式支持 */
@media (prefers-color-scheme: dark) {
  .immersive-translate-result {
    --immersive-translate-color: #8ab4f8;
  }
}

/* 翻译中状态 */
.immersive-translate-loading {
  opacity: 0.7;
  position: relative;
}

.immersive-translate-loading::after {
  content: '';
  position: absolute;
  right: -20px;
  top: 50%;
  width: 14px;
  height: 14px;
  margin-top: -7px;
  border: 2px solid #1a73e8;
  border-top-color: transparent;
  border-radius: 50%;
  animation: immersive-translate-spin 0.8s linear infinite;
}

@keyframes immersive-translate-spin {
  to { transform: rotate(360deg); }
}
```

## 5. 运行准备脚本

```json
// package.json
{
  "scripts": {
    "postinstall": "wxt prepare",
    "dev": "wxt",
    "build": "wxt build",
    "build:all": "wxt build -b chrome && wxt build -b firefox && wxt build -b edge"
  }
}
```

## 总结

本章节完成了:

1. **完整的 i18n 系统** - 支持英语/中文/日语三种语言,可轻松扩展
2. **自动导入配置** - React hooks、工具函数自动导入,提升开发效率  
3. **可复用 Hooks** - useTranslation、useStorage、useMembership
4. **DOM 工具函数** - 文本节点获取、双语元素创建、批量处理
5. **API 请求封装** - 统一的请求处理,支持认证

下一章将介绍后端服务架构,包括 Hono + Drizzle + PostgreSQL 的集成。
