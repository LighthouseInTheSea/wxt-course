# 沉浸式翻译插件 - 可扩展支付系统

## 概述

本章节介绍如何构建一个可扩展的支付系统,支持多种支付渠道(Creem、Stripe 等),采用策略模式设计,便于后续扩展。

## 1. 支付系统架构

### 1.1 设计原则

```
                    +-------------------+
                    |  PaymentService   |  <-- 统一入口
                    +-------------------+
                            |
                    +-------------------+
                    | PaymentProvider   |  <-- 抽象接口
                    +-------------------+
                     /        |        \
            +-------+    +--------+    +--------+
            | Creem |    | Stripe |    | Paddle |
            +-------+    +--------+    +--------+
```

核心设计:
- **策略模式**: 每个支付渠道实现统一接口
- **工厂模式**: 根据配置动态选择支付提供商
- **适配器模式**: 统一不同支付商的 Webhook 格式

### 1.2 支付接口定义

```typescript
// src/services/payment/types.ts

// 支付提供商类型
export type PaymentProviderType = 'creem' | 'stripe' | 'paddle' | 'lemonsqueezy';

// 创建结账会话参数
export interface CreateCheckoutParams {
  userId: string;
  email: string;
  planId: string;
  planType: 'subscription' | 'one_time';
  successUrl: string;
  cancelUrl: string;
  metadata?: Record<string, string>;
}

// 结账会话结果
export interface CheckoutSession {
  id: string;
  url: string;
  provider: PaymentProviderType;
}

// 客户门户会话
export interface PortalSession {
  url: string;
}

// 统一 Webhook 事件
export interface PaymentWebhookEvent {
  type: WebhookEventType;
  provider: PaymentProviderType;
  data: {
    customerId?: string;
    subscriptionId?: string;
    userId?: string;
    email?: string;
    planId?: string;
    amount?: number;
    currency?: string;
    status?: string;
    currentPeriodStart?: Date;
    currentPeriodEnd?: Date;
    cancelAtPeriodEnd?: boolean;
    metadata?: Record<string, string>;
  };
  raw: unknown; // 原始数据
}

export type WebhookEventType =
  | 'checkout.completed'
  | 'subscription.created'
  | 'subscription.updated'
  | 'subscription.canceled'
  | 'subscription.expired'
  | 'payment.succeeded'
  | 'payment.failed'
  | 'refund.created';

// 订阅操作结果
export interface SubscriptionResult {
  id: string;
  status: string;
  currentPeriodEnd?: Date;
}

// 支付提供商接口
export interface PaymentProvider {
  readonly name: PaymentProviderType;
  
  // 初始化检查
  isConfigured(): boolean;
  
  // 创建结账会话
  createCheckoutSession(params: CreateCheckoutParams): Promise<CheckoutSession>;
  
  // 创建客户门户
  createPortalSession(customerId: string, returnUrl: string): Promise<PortalSession>;
  
  // 取消订阅
  cancelSubscription(subscriptionId: string, immediate?: boolean): Promise<SubscriptionResult>;
  
  // 恢复订阅
  resumeSubscription(subscriptionId: string): Promise<SubscriptionResult>;
  
  // 验证并解析 Webhook
  parseWebhook(payload: string, signature: string): Promise<PaymentWebhookEvent>;
  
  // 获取订阅详情
  getSubscription(subscriptionId: string): Promise<SubscriptionResult | null>;
}
```

## 2. Creem 支付实现

### 2.1 Creem Provider

```typescript
// src/services/payment/providers/creem.ts
import { env } from '@/lib/env';
import type {
  PaymentProvider,
  CreateCheckoutParams,
  CheckoutSession,
  PortalSession,
  PaymentWebhookEvent,
  SubscriptionResult,
  WebhookEventType,
} from '../types';

const CREEM_API_BASE = 'https://api.creem.io/v1';

export class CreemProvider implements PaymentProvider {
  readonly name = 'creem' as const;
  private apiKey: string;
  private webhookSecret: string;

  constructor() {
    this.apiKey = env.CREEM_API_KEY;
    this.webhookSecret = env.CREEM_WEBHOOK_SECRET;
  }

  isConfigured(): boolean {
    return !!(this.apiKey && this.webhookSecret);
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const response = await fetch(`${CREEM_API_BASE}${endpoint}`, {
      ...options,
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json',
        ...options.headers,
      },
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(`Creem API error: ${error.message || response.statusText}`);
    }

    return response.json();
  }

  async createCheckoutSession(params: CreateCheckoutParams): Promise<CheckoutSession> {
    const { userId, email, planId, successUrl, cancelUrl, metadata } = params;

    const response = await this.request<{
      id: string;
      checkout_url: string;
    }>('/checkout/sessions', {
      method: 'POST',
      body: JSON.stringify({
        product_id: planId,
        customer_email: email,
        success_url: successUrl,
        cancel_url: cancelUrl,
        metadata: {
          user_id: userId,
          ...metadata,
        },
        allow_promotion_codes: true,
      }),
    });

    return {
      id: response.id,
      url: response.checkout_url,
      provider: 'creem',
    };
  }

  async createPortalSession(customerId: string, returnUrl: string): Promise<PortalSession> {
    const response = await this.request<{
      portal_url: string;
    }>('/billing/portal', {
      method: 'POST',
      body: JSON.stringify({
        customer_id: customerId,
        return_url: returnUrl,
      }),
    });

    return { url: response.portal_url };
  }

  async cancelSubscription(
    subscriptionId: string,
    immediate = false
  ): Promise<SubscriptionResult> {
    const response = await this.request<{
      id: string;
      status: string;
      current_period_end: string;
    }>(`/subscriptions/${subscriptionId}/cancel`, {
      method: 'POST',
      body: JSON.stringify({
        cancel_at_period_end: !immediate,
      }),
    });

    return {
      id: response.id,
      status: response.status,
      currentPeriodEnd: new Date(response.current_period_end),
    };
  }

  async resumeSubscription(subscriptionId: string): Promise<SubscriptionResult> {
    const response = await this.request<{
      id: string;
      status: string;
      current_period_end: string;
    }>(`/subscriptions/${subscriptionId}/resume`, {
      method: 'POST',
    });

    return {
      id: response.id,
      status: response.status,
      currentPeriodEnd: new Date(response.current_period_end),
    };
  }

  async getSubscription(subscriptionId: string): Promise<SubscriptionResult | null> {
    try {
      const response = await this.request<{
        id: string;
        status: string;
        current_period_end: string;
      }>(`/subscriptions/${subscriptionId}`);

      return {
        id: response.id,
        status: response.status,
        currentPeriodEnd: new Date(response.current_period_end),
      };
    } catch {
      return null;
    }
  }

  async parseWebhook(payload: string, signature: string): Promise<PaymentWebhookEvent> {
    // 验证签名
    const isValid = await this.verifyWebhookSignature(payload, signature);
    if (!isValid) {
      throw new Error('Invalid webhook signature');
    }

    const event = JSON.parse(payload);
    return this.normalizeWebhookEvent(event);
  }

  private async verifyWebhookSignature(payload: string, signature: string): Promise<boolean> {
    const encoder = new TextEncoder();
    const key = await crypto.subtle.importKey(
      'raw',
      encoder.encode(this.webhookSecret),
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['verify']
    );

    const signatureBuffer = this.hexToBuffer(signature);
    const payloadBuffer = encoder.encode(payload);

    return crypto.subtle.verify('HMAC', key, signatureBuffer, payloadBuffer);
  }

  private hexToBuffer(hex: string): ArrayBuffer {
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
      bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
    }
    return bytes.buffer;
  }

  private normalizeWebhookEvent(event: any): PaymentWebhookEvent {
    const eventTypeMap: Record<string, WebhookEventType> = {
      'checkout.session.completed': 'checkout.completed',
      'subscription.created': 'subscription.created',
      'subscription.updated': 'subscription.updated',
      'subscription.cancelled': 'subscription.canceled',
      'subscription.expired': 'subscription.expired',
      'payment.succeeded': 'payment.succeeded',
      'payment.failed': 'payment.failed',
      'refund.created': 'refund.created',
    };

    const type = eventTypeMap[event.type] || event.type;
    const data = event.data || {};

    return {
      type,
      provider: 'creem',
      data: {
        customerId: data.customer_id,
        subscriptionId: data.subscription_id,
        userId: data.metadata?.user_id,
        email: data.customer_email,
        planId: data.product_id,
        amount: data.amount,
        currency: data.currency,
        status: data.status,
        currentPeriodStart: data.current_period_start ? new Date(data.current_period_start) : undefined,
        currentPeriodEnd: data.current_period_end ? new Date(data.current_period_end) : undefined,
        cancelAtPeriodEnd: data.cancel_at_period_end,
        metadata: data.metadata,
      },
      raw: event,
    };
  }
}
```

## 3. Stripe 支付实现

### 3.1 Stripe Provider

```typescript
// src/services/payment/providers/stripe.ts
import Stripe from 'stripe';
import { env } from '@/lib/env';
import type {
  PaymentProvider,
  CreateCheckoutParams,
  CheckoutSession,
  PortalSession,
  PaymentWebhookEvent,
  SubscriptionResult,
  WebhookEventType,
} from '../types';

export class StripeProvider implements PaymentProvider {
  readonly name = 'stripe' as const;
  private stripe: Stripe | null = null;
  private webhookSecret: string;

  constructor() {
    if (env.STRIPE_SECRET_KEY) {
      this.stripe = new Stripe(env.STRIPE_SECRET_KEY, {
        apiVersion: '2024-11-20.acacia',
      });
    }
    this.webhookSecret = env.STRIPE_WEBHOOK_SECRET || '';
  }

  isConfigured(): boolean {
    return !!(this.stripe && this.webhookSecret);
  }

  private getStripe(): Stripe {
    if (!this.stripe) {
      throw new Error('Stripe is not configured');
    }
    return this.stripe;
  }

  async createCheckoutSession(params: CreateCheckoutParams): Promise<CheckoutSession> {
    const stripe = this.getStripe();
    const { userId, email, planId, planType, successUrl, cancelUrl, metadata } = params;

    const sessionParams: Stripe.Checkout.SessionCreateParams = {
      customer_email: email,
      success_url: successUrl,
      cancel_url: cancelUrl,
      metadata: {
        user_id: userId,
        ...metadata,
      },
      allow_promotion_codes: true,
    };

    if (planType === 'subscription') {
      sessionParams.mode = 'subscription';
      sessionParams.line_items = [{
        price: planId,
        quantity: 1,
      }];
    } else {
      sessionParams.mode = 'payment';
      sessionParams.line_items = [{
        price: planId,
        quantity: 1,
      }];
    }

    const session = await stripe.checkout.sessions.create(sessionParams);

    return {
      id: session.id,
      url: session.url!,
      provider: 'stripe',
    };
  }

  async createPortalSession(customerId: string, returnUrl: string): Promise<PortalSession> {
    const stripe = this.getStripe();

    const session = await stripe.billingPortal.sessions.create({
      customer: customerId,
      return_url: returnUrl,
    });

    return { url: session.url };
  }

  async cancelSubscription(
    subscriptionId: string,
    immediate = false
  ): Promise<SubscriptionResult> {
    const stripe = this.getStripe();

    let subscription: Stripe.Subscription;

    if (immediate) {
      subscription = await stripe.subscriptions.cancel(subscriptionId);
    } else {
      subscription = await stripe.subscriptions.update(subscriptionId, {
        cancel_at_period_end: true,
      });
    }

    return {
      id: subscription.id,
      status: subscription.status,
      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
    };
  }

  async resumeSubscription(subscriptionId: string): Promise<SubscriptionResult> {
    const stripe = this.getStripe();

    const subscription = await stripe.subscriptions.update(subscriptionId, {
      cancel_at_period_end: false,
    });

    return {
      id: subscription.id,
      status: subscription.status,
      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
    };
  }

  async getSubscription(subscriptionId: string): Promise<SubscriptionResult | null> {
    const stripe = this.getStripe();

    try {
      const subscription = await stripe.subscriptions.retrieve(subscriptionId);
      return {
        id: subscription.id,
        status: subscription.status,
        currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      };
    } catch {
      return null;
    }
  }

  async parseWebhook(payload: string, signature: string): Promise<PaymentWebhookEvent> {
    const stripe = this.getStripe();

    const event = stripe.webhooks.constructEvent(
      payload,
      signature,
      this.webhookSecret
    );

    return this.normalizeWebhookEvent(event);
  }

  private normalizeWebhookEvent(event: Stripe.Event): PaymentWebhookEvent {
    const eventTypeMap: Record<string, WebhookEventType> = {
      'checkout.session.completed': 'checkout.completed',
      'customer.subscription.created': 'subscription.created',
      'customer.subscription.updated': 'subscription.updated',
      'customer.subscription.deleted': 'subscription.canceled',
      'invoice.payment_succeeded': 'payment.succeeded',
      'invoice.payment_failed': 'payment.failed',
      'charge.refunded': 'refund.created',
    };

    const type = eventTypeMap[event.type] || (event.type as WebhookEventType);
    const data = event.data.object as any;

    let normalizedData: PaymentWebhookEvent['data'] = {};

    switch (event.type) {
      case 'checkout.session.completed':
        normalizedData = {
          customerId: data.customer,
          subscriptionId: data.subscription,
          userId: data.metadata?.user_id,
          email: data.customer_email,
          metadata: data.metadata,
        };
        break;

      case 'customer.subscription.created':
      case 'customer.subscription.updated':
      case 'customer.subscription.deleted':
        normalizedData = {
          customerId: data.customer,
          subscriptionId: data.id,
          status: data.status,
          currentPeriodStart: new Date(data.current_period_start * 1000),
          currentPeriodEnd: new Date(data.current_period_end * 1000),
          cancelAtPeriodEnd: data.cancel_at_period_end,
          metadata: data.metadata,
        };
        break;

      case 'invoice.payment_succeeded':
      case 'invoice.payment_failed':
        normalizedData = {
          customerId: data.customer,
          subscriptionId: data.subscription,
          amount: data.amount_paid || data.amount_due,
          currency: data.currency,
          status: data.status,
        };
        break;
    }

    return {
      type,
      provider: 'stripe',
      data: normalizedData,
      raw: event,
    };
  }
}
```

## 4. 支付服务工厂

### 4.1 支付服务管理器

```typescript
// src/services/payment/index.ts
import { CreemProvider } from './providers/creem';
import { StripeProvider } from './providers/stripe';
import type {
  PaymentProvider,
  PaymentProviderType,
  CreateCheckoutParams,
  CheckoutSession,
  PortalSession,
  PaymentWebhookEvent,
  SubscriptionResult,
} from './types';

export * from './types';

class PaymentService {
  private providers: Map<PaymentProviderType, PaymentProvider> = new Map();
  private defaultProvider: PaymentProviderType = 'creem';

  constructor() {
    // 注册所有支付提供商
    this.registerProvider(new CreemProvider());
    this.registerProvider(new StripeProvider());
    // 可以继续添加其他支付提供商
    // this.registerProvider(new PaddleProvider());
    // this.registerProvider(new LemonSqueezyProvider());
  }

  private registerProvider(provider: PaymentProvider): void {
    if (provider.isConfigured()) {
      this.providers.set(provider.name, provider);
      console.log(`Payment provider registered: ${provider.name}`);
    } else {
      console.log(`Payment provider not configured: ${provider.name}`);
    }
  }

  // 获取指定提供商
  getProvider(name: PaymentProviderType): PaymentProvider {
    const provider = this.providers.get(name);
    if (!provider) {
      throw new Error(`Payment provider not found: ${name}`);
    }
    return provider;
  }

  // 获取默认提供商
  getDefaultProvider(): PaymentProvider {
    return this.getProvider(this.defaultProvider);
  }

  // 获取所有可用的提供商
  getAvailableProviders(): PaymentProviderType[] {
    return Array.from(this.providers.keys());
  }

  // 设置默认提供商
  setDefaultProvider(name: PaymentProviderType): void {
    if (!this.providers.has(name)) {
      throw new Error(`Cannot set default provider to unconfigured: ${name}`);
    }
    this.defaultProvider = name;
  }

  // 创建结账会话
  async createCheckoutSession(
    params: CreateCheckoutParams,
    providerName?: PaymentProviderType
  ): Promise<CheckoutSession> {
    const provider = providerName 
      ? this.getProvider(providerName) 
      : this.getDefaultProvider();
    return provider.createCheckoutSession(params);
  }

  // 创建客户门户会话
  async createPortalSession(
    customerId: string,
    returnUrl: string,
    providerName?: PaymentProviderType
  ): Promise<PortalSession> {
    const provider = providerName 
      ? this.getProvider(providerName) 
      : this.getDefaultProvider();
    return provider.createPortalSession(customerId, returnUrl);
  }

  // 取消订阅
  async cancelSubscription(
    subscriptionId: string,
    providerName: PaymentProviderType,
    immediate = false
  ): Promise<SubscriptionResult> {
    const provider = this.getProvider(providerName);
    return provider.cancelSubscription(subscriptionId, immediate);
  }

  // 恢复订阅
  async resumeSubscription(
    subscriptionId: string,
    providerName: PaymentProviderType
  ): Promise<SubscriptionResult> {
    const provider = this.getProvider(providerName);
    return provider.resumeSubscription(subscriptionId);
  }

  // 解析 Webhook
  async parseWebhook(
    payload: string,
    signature: string,
    providerName: PaymentProviderType
  ): Promise<PaymentWebhookEvent> {
    const provider = this.getProvider(providerName);
    return provider.parseWebhook(payload, signature);
  }
}

// 导出单例
export const paymentService = new PaymentService();
```

## 5. Webhook 路由

### 5.1 统一 Webhook 处理

```typescript
// src/routes/webhook.ts
import { Hono } from 'hono';
import { db } from '@/db';
import { subscriptions, payments, users } from '@/db/schema';
import { eq } from 'drizzle-orm';
import { paymentService, type PaymentProviderType } from '@/services/payment';
import type { Env } from '@/app';

export const webhookRoutes = new Hono<Env>();

// Webhook 处理器
async function handleWebhookEvent(
  providerName: PaymentProviderType,
  payload: string,
  signature: string
) {
  const event = await paymentService.parseWebhook(payload, signature, providerName);
  
  console.log(`Webhook received: ${providerName} - ${event.type}`);

  switch (event.type) {
    case 'checkout.completed':
      await handleCheckoutCompleted(event, providerName);
      break;
    case 'subscription.created':
      await handleSubscriptionCreated(event, providerName);
      break;
    case 'subscription.updated':
      await handleSubscriptionUpdated(event, providerName);
      break;
    case 'subscription.canceled':
      await handleSubscriptionCanceled(event, providerName);
      break;
    case 'payment.succeeded':
      await handlePaymentSucceeded(event, providerName);
      break;
    case 'payment.failed':
      await handlePaymentFailed(event, providerName);
      break;
    default:
      console.log(`Unhandled webhook event: ${event.type}`);
  }
}

// 结账完成处理
async function handleCheckoutCompleted(
  event: any,
  provider: PaymentProviderType
) {
  const { userId, subscriptionId, customerId, email, planId } = event.data;

  // 查找或创建用户
  let user = userId 
    ? await db.query.users.findFirst({ where: eq(users.id, userId) })
    : null;

  if (!user && email) {
    user = await db.query.users.findFirst({ where: eq(users.email, email) });
  }

  if (!user) {
    console.error('User not found for checkout:', { userId, email });
    return;
  }

  // 查找计划
  const plan = await db.query.plans.findFirst({
    where: (plans, { or, eq }) => or(
      eq(plans.creemProductId, planId),
      eq(plans.stripePriceId, planId)
    ),
  });

  if (!plan) {
    console.error('Plan not found:', planId);
    return;
  }

  // 创建订阅记录
  await db.insert(subscriptions).values({
    userId: user.id,
    planId: plan.id,
    status: 'active',
    provider,
    providerSubscriptionId: subscriptionId,
    providerCustomerId: customerId,
    currentPeriodStart: new Date(),
    currentPeriodEnd: event.data.currentPeriodEnd || 
      new Date(Date.now() + (plan.interval === 'year' ? 365 : 30) * 24 * 60 * 60 * 1000),
    metadata: event.data.metadata,
  }).onConflictDoUpdate({
    target: [subscriptions.providerSubscriptionId],
    set: {
      status: 'active',
      updatedAt: new Date(),
    },
  });

  console.log(`Subscription created for user ${user.id}`);
}

// 订阅创建处理
async function handleSubscriptionCreated(
  event: any,
  provider: PaymentProviderType
) {
  // 大部分逻辑在 checkout.completed 中处理
  console.log('Subscription created:', event.data.subscriptionId);
}

// 订阅更新处理
async function handleSubscriptionUpdated(
  event: any,
  provider: PaymentProviderType
) {
  const { subscriptionId, status, currentPeriodEnd, cancelAtPeriodEnd } = event.data;

  await db.update(subscriptions)
    .set({
      status: status === 'active' ? 'active' : 
              status === 'past_due' ? 'past_due' : 
              status === 'canceled' ? 'canceled' : 'active',
      currentPeriodEnd,
      cancelAtPeriodEnd,
      updatedAt: new Date(),
    })
    .where(eq(subscriptions.providerSubscriptionId, subscriptionId));

  console.log(`Subscription updated: ${subscriptionId}`);
}

// 订阅取消处理
async function handleSubscriptionCanceled(
  event: any,
  provider: PaymentProviderType
) {
  const { subscriptionId } = event.data;

  await db.update(subscriptions)
    .set({
      status: 'canceled',
      canceledAt: new Date(),
      updatedAt: new Date(),
    })
    .where(eq(subscriptions.providerSubscriptionId, subscriptionId));

  console.log(`Subscription canceled: ${subscriptionId}`);
}

// 支付成功处理
async function handlePaymentSucceeded(
  event: any,
  provider: PaymentProviderType
) {
  const { subscriptionId, amount, currency, customerId } = event.data;

  // 查找订阅获取用户ID
  const subscription = await db.query.subscriptions.findFirst({
    where: eq(subscriptions.providerSubscriptionId, subscriptionId),
  });

  await db.insert(payments).values({
    userId: subscription?.userId,
    subscriptionId: subscription?.id,
    provider,
    providerPaymentId: `${provider}_${Date.now()}`,
    amount: amount || 0,
    currency: currency || 'USD',
    status: 'succeeded',
    metadata: event.data.metadata,
  });

  console.log(`Payment succeeded for subscription: ${subscriptionId}`);
}

// 支付失败处理
async function handlePaymentFailed(
  event: any,
  provider: PaymentProviderType
) {
  const { subscriptionId } = event.data;

  // 更新订阅状态
  await db.update(subscriptions)
    .set({
      status: 'past_due',
      updatedAt: new Date(),
    })
    .where(eq(subscriptions.providerSubscriptionId, subscriptionId));

  // TODO: 发送邮件通知用户

  console.log(`Payment failed for subscription: ${subscriptionId}`);
}

// Creem Webhook
webhookRoutes.post('/creem', async (c) => {
  const payload = await c.req.text();
  const signature = c.req.header('x-creem-signature') || '';

  try {
    await handleWebhookEvent('creem', payload, signature);
    return c.json({ received: true });
  } catch (error) {
    console.error('Creem webhook error:', error);
    return c.json({ error: 'Webhook processing failed' }, 400);
  }
});

// Stripe Webhook
webhookRoutes.post('/stripe', async (c) => {
  const payload = await c.req.text();
  const signature = c.req.header('stripe-signature') || '';

  try {
    await handleWebhookEvent('stripe', payload, signature);
    return c.json({ received: true });
  } catch (error) {
    console.error('Stripe webhook error:', error);
    return c.json({ error: 'Webhook processing failed' }, 400);
  }
});

// 通用 Webhook 端点 (可选)
webhookRoutes.post('/:provider', async (c) => {
  const provider = c.req.param('provider') as PaymentProviderType;
  const payload = await c.req.text();
  
  // 根据提供商获取对应的签名头
  const signatureHeaders: Record<string, string> = {
    creem: 'x-creem-signature',
    stripe: 'stripe-signature',
    paddle: 'paddle-signature',
    lemonsqueezy: 'x-signature',
  };

  const signature = c.req.header(signatureHeaders[provider] || 'x-signature') || '';

  try {
    await handleWebhookEvent(provider, payload, signature);
    return c.json({ received: true });
  } catch (error) {
    console.error(`${provider} webhook error:`, error);
    return c.json({ error: 'Webhook processing failed' }, 400);
  }
});
```

## 6. 订阅管理路由

```typescript
// src/routes/subscription.ts
import { Hono } from 'hono';
import { z } from 'zod';
import { zValidator } from '@hono/zod-validator';
import { db } from '@/db';
import { subscriptions, plans } from '@/db/schema';
import { eq, and, desc } from 'drizzle-orm';
import { requireAuth } from '@/middleware/auth';
import { getMembershipInfo } from '@/middleware/membership';
import { paymentService } from '@/services/payment';
import { env } from '@/lib/env';
import type { Env } from '@/app';

export const subscriptionRoutes = new Hono<Env>();

// 获取所有计划
subscriptionRoutes.get('/plans', async (c) => {
  const allPlans = await db.query.plans.findMany({
    where: eq(plans.isActive, true),
    orderBy: [plans.price],
  });

  return c.json({ plans: allPlans });
});

// 获取当前用户的会员信息
subscriptionRoutes.get('/membership', requireAuth, async (c) => {
  const user = c.get('user')!;
  const membership = await getMembershipInfo(user.id);
  return c.json(membership);
});

// 获取用户的订阅历史
subscriptionRoutes.get('/history', requireAuth, async (c) => {
  const user = c.get('user')!;

  const history = await db.query.subscriptions.findMany({
    where: eq(subscriptions.userId, user.id),
    with: {
      plan: true,
    },
    orderBy: [desc(subscriptions.createdAt)],
  });

  return c.json({ subscriptions: history });
});

// 创建结账会话
const checkoutSchema = z.object({
  planId: z.string().uuid(),
  provider: z.enum(['creem', 'stripe']).optional(),
});

subscriptionRoutes.post(
  '/checkout',
  requireAuth,
  zValidator('json', checkoutSchema),
  async (c) => {
    const user = c.get('user')!;
    const { planId, provider } = c.req.valid('json');

    // 查找计划
    const plan = await db.query.plans.findFirst({
      where: eq(plans.id, planId),
    });

    if (!plan) {
      return c.json({ error: 'Plan not found' }, 404);
    }

    // 检查用户是否已有活跃订阅
    const existingSubscription = await db.query.subscriptions.findFirst({
      where: and(
        eq(subscriptions.userId, user.id),
        eq(subscriptions.status, 'active')
      ),
    });

    if (existingSubscription) {
      return c.json({ 
        error: 'You already have an active subscription',
        code: 'ALREADY_SUBSCRIBED',
      }, 400);
    }

    // 根据提供商获取对应的产品ID
    const selectedProvider = provider || 'creem';
    const productId = selectedProvider === 'stripe' 
      ? plan.stripePriceId 
      : plan.creemProductId;

    if (!productId) {
      return c.json({ 
        error: `Plan not available for ${selectedProvider}`,
      }, 400);
    }

    // 创建结账会话
    const session = await paymentService.createCheckoutSession({
      userId: user.id,
      email: user.email,
      planId: productId,
      planType: plan.interval ? 'subscription' : 'one_time',
      successUrl: `${env.FRONTEND_URL}/payment/success?session_id={CHECKOUT_SESSION_ID}`,
      cancelUrl: `${env.FRONTEND_URL}/pricing`,
      metadata: {
        plan_name: plan.name,
      },
    }, selectedProvider as any);

    return c.json(session);
  }
);

// 创建客户门户会话
subscriptionRoutes.post('/portal', requireAuth, async (c) => {
  const user = c.get('user')!;

  // 查找用户的活跃订阅
  const subscription = await db.query.subscriptions.findFirst({
    where: and(
      eq(subscriptions.userId, user.id),
      eq(subscriptions.status, 'active')
    ),
  });

  if (!subscription || !subscription.providerCustomerId) {
    return c.json({ error: 'No active subscription found' }, 404);
  }

  const portal = await paymentService.createPortalSession(
    subscription.providerCustomerId,
    `${env.FRONTEND_URL}/settings`,
    subscription.provider as any
  );

  return c.json(portal);
});

// 取消订阅
subscriptionRoutes.post('/cancel', requireAuth, async (c) => {
  const user = c.get('user')!;

  const subscription = await db.query.subscriptions.findFirst({
    where: and(
      eq(subscriptions.userId, user.id),
      eq(subscriptions.status, 'active')
    ),
  });

  if (!subscription || !subscription.providerSubscriptionId) {
    return c.json({ error: 'No active subscription found' }, 404);
  }

  const result = await paymentService.cancelSubscription(
    subscription.providerSubscriptionId,
    subscription.provider as any,
    false // 在周期结束时取消
  );

  // 更新本地记录
  await db.update(subscriptions)
    .set({
      cancelAtPeriodEnd: true,
      updatedAt: new Date(),
    })
    .where(eq(subscriptions.id, subscription.id));

  return c.json({
    message: 'Subscription will be canceled at the end of the billing period',
    cancelAt: result.currentPeriodEnd,
  });
});

// 恢复订阅
subscriptionRoutes.post('/resume', requireAuth, async (c) => {
  const user = c.get('user')!;

  const subscription = await db.query.subscriptions.findFirst({
    where: and(
      eq(subscriptions.userId, user.id),
      eq(subscriptions.cancelAtPeriodEnd, true)
    ),
  });

  if (!subscription || !subscription.providerSubscriptionId) {
    return c.json({ error: 'No canceled subscription found' }, 404);
  }

  await paymentService.resumeSubscription(
    subscription.providerSubscriptionId,
    subscription.provider as any
  );

  await db.update(subscriptions)
    .set({
      cancelAtPeriodEnd: false,
      updatedAt: new Date(),
    })
    .where(eq(subscriptions.id, subscription.id));

  return c.json({ message: 'Subscription resumed' });
});
```

## 7. 扩展新的支付渠道

### 7.1 添加新提供商模板

```typescript
// src/services/payment/providers/template.ts
import type {
  PaymentProvider,
  CreateCheckoutParams,
  CheckoutSession,
  PortalSession,
  PaymentWebhookEvent,
  SubscriptionResult,
} from '../types';

/**
 * 新支付提供商模板
 * 复制此文件并实现所有方法
 */
export class NewProvider implements PaymentProvider {
  readonly name = 'new_provider' as const;

  isConfigured(): boolean {
    // 检查必要的环境变量
    return !!process.env.NEW_PROVIDER_API_KEY;
  }

  async createCheckoutSession(params: CreateCheckoutParams): Promise<CheckoutSession> {
    // 实现创建结账会话逻辑
    throw new Error('Not implemented');
  }

  async createPortalSession(customerId: string, returnUrl: string): Promise<PortalSession> {
    // 实现创建客户门户逻辑
    throw new Error('Not implemented');
  }

  async cancelSubscription(subscriptionId: string, immediate?: boolean): Promise<SubscriptionResult> {
    // 实现取消订阅逻辑
    throw new Error('Not implemented');
  }

  async resumeSubscription(subscriptionId: string): Promise<SubscriptionResult> {
    // 实现恢复订阅逻辑
    throw new Error('Not implemented');
  }

  async parseWebhook(payload: string, signature: string): Promise<PaymentWebhookEvent> {
    // 实现 Webhook 解析逻辑
    throw new Error('Not implemented');
  }

  async getSubscription(subscriptionId: string): Promise<SubscriptionResult | null> {
    // 实现获取订阅详情逻辑
    throw new Error('Not implemented');
  }
}
```

### 7.2 注册新提供商

```typescript
// 在 src/services/payment/index.ts 中添加

import { NewProvider } from './providers/new_provider';

// 在构造函数中注册
constructor() {
  this.registerProvider(new CreemProvider());
  this.registerProvider(new StripeProvider());
  this.registerProvider(new NewProvider()); // 添加新提供商
}
```

## 总结

本章节完成了:

1. **支付系统架构** - 策略模式设计,支持多支付渠道
2. **Creem 集成** - 完整的 API 封装和 Webhook 处理
3. **Stripe 集成** - 作为备选支付渠道
4. **统一 Webhook 处理** - 标准化的事件格式和处理流程
5. **订阅管理 API** - 完整的 CRUD 操作
6. **扩展指南** - 添加新支付渠道的模板

下一章将介绍落地页和定价页面的实现。
