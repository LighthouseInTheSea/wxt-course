# 沉浸式翻译插件 - 会员系统与AI翻译服务

## 概述

本章节介绍如何实现会员系统与AI翻译服务的集成。会员用户可以直接使用系统提供的AI翻译,无需配置自己的API Key。

## 1. 会员权限中间件

### 1.1 会员信息获取

```typescript
// src/middleware/membership.ts
import { createMiddleware } from 'hono/factory';
import { db } from '@/db';
import { users, subscriptions, plans } from '@/db/schema';
import { eq, and, gte } from 'drizzle-orm';
import type { Env } from '@/app';

// 会员等级
export type MembershipTier = 'free' | 'pro' | 'lifetime';

// 会员信息
export interface MembershipInfo {
  tier: MembershipTier;
  isActive: boolean;
  subscription: {
    id: string;
    planName: string;
    status: string;
    currentPeriodEnd: Date | null;
    cancelAtPeriodEnd: boolean;
  } | null;
  limits: {
    dailyCharacters: number;
    monthlyCharacters: number;
    hasGPT4Access: boolean;
    hasDeepLAccess: boolean;
    hasPDFTranslation: boolean;
    supportedLanguages: number;
  };
  usage: {
    dailyCharactersUsed: number;
    monthlyCharactersUsed: number;
  };
}

// 获取会员信息
export async function getMembershipInfo(userId: string): Promise<MembershipInfo> {
  // 查询用户的活跃订阅
  const subscription = await db.query.subscriptions.findFirst({
    where: and(
      eq(subscriptions.userId, userId),
      eq(subscriptions.status, 'active'),
      gte(subscriptions.currentPeriodEnd, new Date())
    ),
    with: {
      plan: true,
    },
  });

  // 查询用户使用量
  const user = await db.query.users.findFirst({
    where: eq(users.id, userId),
    columns: {
      dailyCharactersUsed: true,
      monthlyCharactersUsed: true,
      lastUsageReset: true,
    },
  });

  // 检查是否需要重置使用量
  const now = new Date();
  let dailyUsed = user?.dailyCharactersUsed || 0;
  let monthlyUsed = user?.monthlyCharactersUsed || 0;

  if (user?.lastUsageReset) {
    const lastReset = new Date(user.lastUsageReset);
    
    // 每日重置
    if (lastReset.toDateString() !== now.toDateString()) {
      dailyUsed = 0;
    }
    
    // 每月重置
    if (lastReset.getMonth() !== now.getMonth() || 
        lastReset.getFullYear() !== now.getFullYear()) {
      monthlyUsed = 0;
    }
  }

  // 确定会员等级
  let tier: MembershipTier = 'free';
  if (subscription) {
    tier = subscription.plan.type === 'lifetime' ? 'lifetime' : 'pro';
  }

  // 根据等级设置限制
  const limits = getTierLimits(tier);

  return {
    tier,
    isActive: !!subscription,
    subscription: subscription ? {
      id: subscription.id,
      planName: subscription.plan.name,
      status: subscription.status,
      currentPeriodEnd: subscription.currentPeriodEnd,
      cancelAtPeriodEnd: subscription.cancelAtPeriodEnd || false,
    } : null,
    limits,
    usage: {
      dailyCharactersUsed: dailyUsed,
      monthlyCharactersUsed: monthlyUsed,
    },
  };
}

// 获取等级限制
function getTierLimits(tier: MembershipTier) {
  const tierLimits = {
    free: {
      dailyCharacters: 1000,
      monthlyCharacters: 10000,
      hasGPT4Access: false,
      hasDeepLAccess: false,
      hasPDFTranslation: false,
      supportedLanguages: 10,
    },
    pro: {
      dailyCharacters: -1, // 无限制
      monthlyCharacters: -1,
      hasGPT4Access: true,
      hasDeepLAccess: true,
      hasPDFTranslation: true,
      supportedLanguages: 100,
    },
    lifetime: {
      dailyCharacters: -1,
      monthlyCharacters: -1,
      hasGPT4Access: true,
      hasDeepLAccess: true,
      hasPDFTranslation: true,
      supportedLanguages: 100,
    },
  };

  return tierLimits[tier];
}

// 会员验证中间件
export const requireMembership = (requiredTier: MembershipTier = 'pro') => {
  return createMiddleware<Env>(async (c, next) => {
    const user = c.get('user');
    if (!user) {
      return c.json({ error: 'Authentication required' }, 401);
    }

    const membership = await getMembershipInfo(user.id);
    c.set('membership', membership);

    const tierOrder: MembershipTier[] = ['free', 'pro', 'lifetime'];
    const userTierIndex = tierOrder.indexOf(membership.tier);
    const requiredTierIndex = tierOrder.indexOf(requiredTier);

    if (userTierIndex < requiredTierIndex) {
      return c.json({
        error: 'Membership upgrade required',
        code: 'MEMBERSHIP_REQUIRED',
        currentTier: membership.tier,
        requiredTier,
      }, 403);
    }

    await next();
  });
};

// 使用量检查中间件
export const checkUsageLimit = createMiddleware<Env>(async (c, next) => {
  const user = c.get('user');
  if (!user) {
    return c.json({ error: 'Authentication required' }, 401);
  }

  const membership = await getMembershipInfo(user.id);
  c.set('membership', membership);

  const { limits, usage } = membership;

  // 检查每日限制
  if (limits.dailyCharacters > 0 && usage.dailyCharactersUsed >= limits.dailyCharacters) {
    return c.json({
      error: 'Daily character limit exceeded',
      code: 'DAILY_LIMIT_EXCEEDED',
      limit: limits.dailyCharacters,
      used: usage.dailyCharactersUsed,
      resetAt: getNextDayReset(),
    }, 429);
  }

  // 检查每月限制
  if (limits.monthlyCharacters > 0 && usage.monthlyCharactersUsed >= limits.monthlyCharacters) {
    return c.json({
      error: 'Monthly character limit exceeded',
      code: 'MONTHLY_LIMIT_EXCEEDED',
      limit: limits.monthlyCharacters,
      used: usage.monthlyCharactersUsed,
      resetAt: getNextMonthReset(),
    }, 429);
  }

  await next();
});

function getNextDayReset(): Date {
  const tomorrow = new Date();
  tomorrow.setDate(tomorrow.getDate() + 1);
  tomorrow.setHours(0, 0, 0, 0);
  return tomorrow;
}

function getNextMonthReset(): Date {
  const nextMonth = new Date();
  nextMonth.setMonth(nextMonth.getMonth() + 1);
  nextMonth.setDate(1);
  nextMonth.setHours(0, 0, 0, 0);
  return nextMonth;
}
```

## 2. AI 翻译服务

### 2.1 翻译服务抽象

```typescript
// src/services/translation/types.ts

export type TranslationEngine = 'openai' | 'deepl' | 'google' | 'azure';

export interface TranslationRequest {
  text: string | string[];
  sourceLang: string;
  targetLang: string;
  engine?: TranslationEngine;
  context?: string; // 上下文信息,用于提高翻译质量
}

export interface TranslationResult {
  translations: {
    original: string;
    translated: string;
  }[];
  engine: TranslationEngine;
  charactersUsed: number;
  cached: boolean;
}

export interface TranslationProvider {
  readonly name: TranslationEngine;
  isConfigured(): boolean;
  translate(request: TranslationRequest): Promise<TranslationResult>;
  getSupportedLanguages(): string[];
}
```

### 2.2 OpenAI GPT-4 翻译

```typescript
// src/services/translation/providers/openai.ts
import OpenAI from 'openai';
import { env } from '@/lib/env';
import type { TranslationProvider, TranslationRequest, TranslationResult } from '../types';

export class OpenAITranslationProvider implements TranslationProvider {
  readonly name = 'openai' as const;
  private client: OpenAI | null = null;

  constructor() {
    if (env.OPENAI_API_KEY) {
      this.client = new OpenAI({
        apiKey: env.OPENAI_API_KEY,
        baseURL: env.OPENAI_BASE_URL || undefined,
      });
    }
  }

  isConfigured(): boolean {
    return !!this.client;
  }

  async translate(request: TranslationRequest): Promise<TranslationResult> {
    if (!this.client) {
      throw new Error('OpenAI is not configured');
    }

    const texts = Array.isArray(request.text) ? request.text : [request.text];
    const totalChars = texts.reduce((sum, t) => sum + t.length, 0);

    // 构建翻译提示
    const systemPrompt = this.buildSystemPrompt(request.sourceLang, request.targetLang, request.context);
    const userPrompt = this.buildUserPrompt(texts);

    const response = await this.client.chat.completions.create({
      model: env.OPENAI_MODEL || 'gpt-4-turbo-preview',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ],
      temperature: 0.3,
      max_tokens: 4096,
    });

    const content = response.choices[0]?.message?.content || '';
    const translations = this.parseTranslations(texts, content);

    return {
      translations,
      engine: 'openai',
      charactersUsed: totalChars,
      cached: false,
    };
  }

  private buildSystemPrompt(sourceLang: string, targetLang: string, context?: string): string {
    let prompt = `You are a professional translator. Translate the following text from ${sourceLang} to ${targetLang}.

Rules:
1. Maintain the original meaning and tone
2. Keep proper nouns, technical terms, and brand names unchanged when appropriate
3. Preserve formatting (line breaks, punctuation)
4. Translate naturally, not word-by-word
5. If the text contains code or URLs, keep them unchanged`;

    if (context) {
      prompt += `\n\nContext for better translation: ${context}`;
    }

    prompt += `\n\nRespond with a JSON array of translated strings, maintaining the same order as input.
Example: ["translated text 1", "translated text 2"]`;

    return prompt;
  }

  private buildUserPrompt(texts: string[]): string {
    return JSON.stringify(texts);
  }

  private parseTranslations(originals: string[], response: string): TranslationResult['translations'] {
    try {
      // 尝试解析JSON数组
      const jsonMatch = response.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        const translated: string[] = JSON.parse(jsonMatch[0]);
        return originals.map((original, i) => ({
          original,
          translated: translated[i] || original,
        }));
      }
    } catch {
      // 解析失败,返回原文
    }

    // 如果只有一个文本,直接返回响应
    if (originals.length === 1) {
      return [{ original: originals[0], translated: response.trim() }];
    }

    // 解析失败,返回原文
    return originals.map(original => ({ original, translated: original }));
  }

  getSupportedLanguages(): string[] {
    // GPT-4 支持几乎所有语言
    return ['*'];
  }
}
```

### 2.3 DeepL 翻译

```typescript
// src/services/translation/providers/deepl.ts
import { env } from '@/lib/env';
import type { TranslationProvider, TranslationRequest, TranslationResult } from '../types';

const DEEPL_API_BASE = 'https://api-free.deepl.com/v2'; // 或 api.deepl.com 用于付费版

export class DeepLTranslationProvider implements TranslationProvider {
  readonly name = 'deepl' as const;
  private apiKey: string;

  constructor() {
    this.apiKey = env.DEEPL_API_KEY || '';
  }

  isConfigured(): boolean {
    return !!this.apiKey;
  }

  async translate(request: TranslationRequest): Promise<TranslationResult> {
    const texts = Array.isArray(request.text) ? request.text : [request.text];
    const totalChars = texts.reduce((sum, t) => sum + t.length, 0);

    const response = await fetch(`${DEEPL_API_BASE}/translate`, {
      method: 'POST',
      headers: {
        'Authorization': `DeepL-Auth-Key ${this.apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        text: texts,
        source_lang: this.normalizeLanguage(request.sourceLang, 'source'),
        target_lang: this.normalizeLanguage(request.targetLang, 'target'),
        preserve_formatting: true,
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(`DeepL API error: ${error.message || response.statusText}`);
    }

    const data = await response.json();
    const translations = texts.map((original, i) => ({
      original,
      translated: data.translations[i]?.text || original,
    }));

    return {
      translations,
      engine: 'deepl',
      charactersUsed: totalChars,
      cached: false,
    };
  }

  private normalizeLanguage(lang: string, type: 'source' | 'target'): string {
    // DeepL 使用特定的语言代码格式
    const langMap: Record<string, string> = {
      'en': type === 'target' ? 'EN-US' : 'EN',
      'zh': 'ZH',
      'zh-CN': 'ZH',
      'zh-TW': 'ZH',
      'ja': 'JA',
      'ko': 'KO',
      'de': 'DE',
      'fr': 'FR',
      'es': 'ES',
      'pt': type === 'target' ? 'PT-BR' : 'PT',
      'ru': 'RU',
      'it': 'IT',
    };
    return langMap[lang] || lang.toUpperCase();
  }

  getSupportedLanguages(): string[] {
    return [
      'BG', 'CS', 'DA', 'DE', 'EL', 'EN', 'ES', 'ET', 'FI', 'FR',
      'HU', 'ID', 'IT', 'JA', 'KO', 'LT', 'LV', 'NB', 'NL', 'PL',
      'PT', 'RO', 'RU', 'SK', 'SL', 'SV', 'TR', 'UK', 'ZH',
    ];
  }
}
```

### 2.4 翻译服务管理器

```typescript
// src/services/translation/index.ts
import { OpenAITranslationProvider } from './providers/openai';
import { DeepLTranslationProvider } from './providers/deepl';
import { db } from '@/db';
import { translationCache, users } from '@/db/schema';
import { eq, and, sql } from 'drizzle-orm';
import type {
  TranslationProvider,
  TranslationEngine,
  TranslationRequest,
  TranslationResult,
} from './types';

export * from './types';

class TranslationService {
  private providers: Map<TranslationEngine, TranslationProvider> = new Map();
  private defaultEngine: TranslationEngine = 'openai';

  constructor() {
    this.registerProvider(new OpenAITranslationProvider());
    this.registerProvider(new DeepLTranslationProvider());
  }

  private registerProvider(provider: TranslationProvider): void {
    if (provider.isConfigured()) {
      this.providers.set(provider.name, provider);
      console.log(`Translation provider registered: ${provider.name}`);
    }
  }

  getProvider(name: TranslationEngine): TranslationProvider {
    const provider = this.providers.get(name);
    if (!provider) {
      throw new Error(`Translation provider not found: ${name}`);
    }
    return provider;
  }

  getAvailableEngines(): TranslationEngine[] {
    return Array.from(this.providers.keys());
  }

  // 带缓存的翻译
  async translate(
    request: TranslationRequest,
    userId?: string
  ): Promise<TranslationResult> {
    const engine = request.engine || this.defaultEngine;
    const texts = Array.isArray(request.text) ? request.text : [request.text];

    // 检查缓存
    const cachedResults = await this.checkCache(texts, request.targetLang, engine);
    const uncachedTexts: string[] = [];
    const uncachedIndices: number[] = [];

    texts.forEach((text, i) => {
      if (!cachedResults[i]) {
        uncachedTexts.push(text);
        uncachedIndices.push(i);
      }
    });

    let newTranslations: TranslationResult['translations'] = [];
    let charactersUsed = 0;

    // 翻译未缓存的文本
    if (uncachedTexts.length > 0) {
      const provider = this.getProvider(engine);
      const result = await provider.translate({
        ...request,
        text: uncachedTexts,
      });

      newTranslations = result.translations;
      charactersUsed = result.charactersUsed;

      // 保存到缓存
      await this.saveCache(newTranslations, request.targetLang, engine);
    }

    // 合并结果
    const finalTranslations: TranslationResult['translations'] = [];
    let uncachedIndex = 0;

    texts.forEach((text, i) => {
      if (cachedResults[i]) {
        finalTranslations.push({
          original: text,
          translated: cachedResults[i]!,
        });
      } else {
        finalTranslations.push(newTranslations[uncachedIndex++]);
      }
    });

    // 更新用户使用量
    if (userId && charactersUsed > 0) {
      await this.updateUsage(userId, charactersUsed);
    }

    return {
      translations: finalTranslations,
      engine,
      charactersUsed,
      cached: uncachedTexts.length === 0,
    };
  }

  // 检查缓存
  private async checkCache(
    texts: string[],
    targetLang: string,
    engine: TranslationEngine
  ): Promise<(string | null)[]> {
    const results: (string | null)[] = new Array(texts.length).fill(null);

    // 计算文本哈希
    const hashes = await Promise.all(texts.map(t => this.hashText(t)));

    // 批量查询缓存
    const cached = await db.query.translationCache.findMany({
      where: and(
        sql`${translationCache.sourceHash} IN ${hashes}`,
        eq(translationCache.targetLang, targetLang),
        eq(translationCache.engine, engine)
      ),
    });

    // 映射结果
    const cacheMap = new Map(cached.map(c => [c.sourceHash, c.translatedText]));
    hashes.forEach((hash, i) => {
      results[i] = cacheMap.get(hash) || null;
    });

    return results;
  }

  // 保存到缓存
  private async saveCache(
    translations: TranslationResult['translations'],
    targetLang: string,
    engine: TranslationEngine
  ): Promise<void> {
    const values = await Promise.all(
      translations.map(async (t) => ({
        sourceHash: await this.hashText(t.original),
        sourceText: t.original.substring(0, 1000), // 只存储前1000字符用于调试
        translatedText: t.translated,
        targetLang,
        engine,
      }))
    );

    await db.insert(translationCache)
      .values(values)
      .onConflictDoNothing();
  }

  // 计算文本哈希
  private async hashText(text: string): Promise<string> {
    const encoder = new TextEncoder();
    const data = encoder.encode(text);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }

  // 更新使用量
  private async updateUsage(userId: string, characters: number): Promise<void> {
    const now = new Date();
    
    await db.update(users)
      .set({
        dailyCharactersUsed: sql`
          CASE 
            WHEN DATE(${users.lastUsageReset}) < DATE(${now}) 
            THEN ${characters}
            ELSE ${users.dailyCharactersUsed} + ${characters}
          END
        `,
        monthlyCharactersUsed: sql`
          CASE 
            WHEN EXTRACT(MONTH FROM ${users.lastUsageReset}) < EXTRACT(MONTH FROM ${now})
              OR EXTRACT(YEAR FROM ${users.lastUsageReset}) < EXTRACT(YEAR FROM ${now})
            THEN ${characters}
            ELSE ${users.monthlyCharactersUsed} + ${characters}
          END
        `,
        lastUsageReset: now,
        updatedAt: now,
      })
      .where(eq(users.id, userId));
  }
}

export const translationService = new TranslationService();
```

## 3. 翻译 API 路由

### 3.1 翻译端点

```typescript
// src/routes/translate.ts
import { Hono } from 'hono';
import { z } from 'zod';
import { zValidator } from '@hono/zod-validator';
import { requireAuth } from '@/middleware/auth';
import { checkUsageLimit, getMembershipInfo } from '@/middleware/membership';
import { translationService } from '@/services/translation';
import type { Env } from '@/app';

export const translateRoutes = new Hono<Env>();

// 翻译请求验证
const translateSchema = z.object({
  text: z.union([
    z.string().min(1).max(10000),
    z.array(z.string().min(1).max(10000)).max(100),
  ]),
  sourceLang: z.string().min(2).max(10),
  targetLang: z.string().min(2).max(10),
  engine: z.enum(['openai', 'deepl', 'google', 'azure']).optional(),
  context: z.string().max(500).optional(),
});

// 翻译接口 (需要认证和使用量检查)
translateRoutes.post(
  '/',
  requireAuth,
  checkUsageLimit,
  zValidator('json', translateSchema),
  async (c) => {
    const user = c.get('user')!;
    const membership = c.get('membership')!;
    const body = c.req.valid('json');

    // 检查引擎访问权限
    const engine = body.engine || 'openai';
    if (engine === 'openai' && !membership.limits.hasGPT4Access) {
      // 免费用户只能使用基础翻译
      return c.json({
        error: 'GPT-4 translation requires Pro membership',
        code: 'ENGINE_NOT_ALLOWED',
      }, 403);
    }

    if (engine === 'deepl' && !membership.limits.hasDeepLAccess) {
      return c.json({
        error: 'DeepL translation requires Pro membership',
        code: 'ENGINE_NOT_ALLOWED',
      }, 403);
    }

    try {
      const result = await translationService.translate({
        text: body.text,
        sourceLang: body.sourceLang,
        targetLang: body.targetLang,
        engine,
        context: body.context,
      }, user.id);

      return c.json({
        success: true,
        data: result,
        usage: {
          charactersUsed: result.charactersUsed,
          dailyRemaining: membership.limits.dailyCharacters > 0
            ? membership.limits.dailyCharacters - membership.usage.dailyCharactersUsed - result.charactersUsed
            : -1,
          monthlyRemaining: membership.limits.monthlyCharacters > 0
            ? membership.limits.monthlyCharacters - membership.usage.monthlyCharactersUsed - result.charactersUsed
            : -1,
        },
      });
    } catch (error) {
      console.error('Translation error:', error);
      return c.json({
        error: 'Translation failed',
        message: error instanceof Error ? error.message : 'Unknown error',
      }, 500);
    }
  }
);

// 获取可用引擎
translateRoutes.get('/engines', requireAuth, async (c) => {
  const membership = c.get('membership') || await getMembershipInfo(c.get('user')!.id);

  const engines = translationService.getAvailableEngines().map(engine => ({
    id: engine,
    name: engine.charAt(0).toUpperCase() + engine.slice(1),
    available: engine === 'openai' ? membership.limits.hasGPT4Access :
               engine === 'deepl' ? membership.limits.hasDeepLAccess :
               true,
    requiresPro: engine === 'openai' || engine === 'deepl',
  }));

  return c.json({ engines });
});

// 获取使用统计
translateRoutes.get('/usage', requireAuth, async (c) => {
  const user = c.get('user')!;
  const membership = await getMembershipInfo(user.id);

  return c.json({
    tier: membership.tier,
    limits: membership.limits,
    usage: membership.usage,
    subscription: membership.subscription,
  });
});

// 批量翻译 (用于PDF等)
const batchTranslateSchema = z.object({
  items: z.array(z.object({
    id: z.string(),
    text: z.string().min(1).max(10000),
  })).max(500),
  sourceLang: z.string().min(2).max(10),
  targetLang: z.string().min(2).max(10),
  engine: z.enum(['openai', 'deepl', 'google', 'azure']).optional(),
});

translateRoutes.post(
  '/batch',
  requireAuth,
  checkUsageLimit,
  zValidator('json', batchTranslateSchema),
  async (c) => {
    const user = c.get('user')!;
    const membership = c.get('membership')!;
    const body = c.req.valid('json');

    // 检查PDF翻译权限
    if (!membership.limits.hasPDFTranslation) {
      return c.json({
        error: 'Batch translation requires Pro membership',
        code: 'FEATURE_NOT_ALLOWED',
      }, 403);
    }

    const texts = body.items.map(item => item.text);
    const result = await translationService.translate({
      text: texts,
      sourceLang: body.sourceLang,
      targetLang: body.targetLang,
      engine: body.engine,
    }, user.id);

    // 映射回原始ID
    const translations = body.items.map((item, i) => ({
      id: item.id,
      original: item.text,
      translated: result.translations[i]?.translated || item.text,
    }));

    return c.json({
      success: true,
      translations,
      usage: {
        charactersUsed: result.charactersUsed,
      },
    });
  }
);
```

## 4. 插件端集成

### 4.1 插件翻译服务

```typescript
// entrypoints/services/memberTranslation.ts
import { storage } from 'wxt/storage';

const API_BASE = import.meta.env.VITE_API_URL || 'https://api.example.com';

interface TranslateOptions {
  text: string | string[];
  sourceLang: string;
  targetLang: string;
  engine?: 'openai' | 'deepl' | 'google';
}

interface TranslateResult {
  translations: {
    original: string;
    translated: string;
  }[];
  charactersUsed: number;
  cached: boolean;
}

// 会员翻译服务
export const memberTranslationService = {
  // 检查是否已登录
  async isAuthenticated(): Promise<boolean> {
    const token = await storage.getItem<string>('local:auth_token');
    return !!token;
  },

  // 获取认证头
  async getAuthHeaders(): Promise<HeadersInit> {
    const token = await storage.getItem<string>('local:auth_token');
    return token ? { Authorization: `Bearer ${token}` } : {};
  },

  // 使用会员API翻译
  async translate(options: TranslateOptions): Promise<TranslateResult> {
    const headers = await this.getAuthHeaders();

    const response = await fetch(`${API_BASE}/api/translate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      body: JSON.stringify(options),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Translation failed');
    }

    const result = await response.json();
    return result.data;
  },

  // 获取使用情况
  async getUsage(): Promise<{
    tier: string;
    dailyRemaining: number;
    monthlyRemaining: number;
  }> {
    const headers = await this.getAuthHeaders();

    const response = await fetch(`${API_BASE}/api/translate/usage`, {
      headers,
    });

    if (!response.ok) {
      throw new Error('Failed to get usage');
    }

    const data = await response.json();
    return {
      tier: data.tier,
      dailyRemaining: data.limits.dailyCharacters > 0
        ? data.limits.dailyCharacters - data.usage.dailyCharactersUsed
        : -1,
      monthlyRemaining: data.limits.monthlyCharacters > 0
        ? data.limits.monthlyCharacters - data.usage.monthlyCharactersUsed
        : -1,
    };
  },

  // 获取可用引擎
  async getAvailableEngines(): Promise<{
    id: string;
    name: string;
    available: boolean;
  }[]> {
    const headers = await this.getAuthHeaders();

    const response = await fetch(`${API_BASE}/api/translate/engines`, {
      headers,
    });

    if (!response.ok) {
      return [{ id: 'google', name: 'Google', available: true }];
    }

    const data = await response.json();
    return data.engines;
  },
};
```

### 4.2 统一翻译服务

```typescript
// entrypoints/services/unifiedTranslation.ts
import { storage } from 'wxt/storage';
import { memberTranslationService } from './memberTranslation';
import { freeTranslationService } from './freeTranslation';

// 用户设置
interface TranslationSettings {
  useMemberAPI: boolean;
  customAPIKey?: string;
  preferredEngine: string;
}

// 统一翻译接口
export const unifiedTranslationService = {
  // 获取设置
  async getSettings(): Promise<TranslationSettings> {
    const settings = await storage.getItem<TranslationSettings>('local:translation_settings');
    return settings || {
      useMemberAPI: true,
      preferredEngine: 'openai',
    };
  },

  // 翻译
  async translate(
    text: string | string[],
    sourceLang: string,
    targetLang: string
  ): Promise<{ original: string; translated: string }[]> {
    const settings = await this.getSettings();
    const isAuthenticated = await memberTranslationService.isAuthenticated();

    // 优先使用会员API
    if (settings.useMemberAPI && isAuthenticated) {
      try {
        const result = await memberTranslationService.translate({
          text,
          sourceLang,
          targetLang,
          engine: settings.preferredEngine as any,
        });
        return result.translations;
      } catch (error) {
        console.warn('Member API failed, falling back to free service:', error);
      }
    }

    // 使用用户自己的API Key
    if (settings.customAPIKey) {
      try {
        return await this.translateWithCustomKey(text, sourceLang, targetLang, settings);
      } catch (error) {
        console.warn('Custom API failed, falling back to free service:', error);
      }
    }

    // 回退到免费服务
    return freeTranslationService.translate(text, sourceLang, targetLang);
  },

  // 使用自定义API Key翻译
  async translateWithCustomKey(
    text: string | string[],
    sourceLang: string,
    targetLang: string,
    settings: TranslationSettings
  ): Promise<{ original: string; translated: string }[]> {
    // 根据用户配置的引擎调用对应API
    const texts = Array.isArray(text) ? text : [text];

    if (settings.preferredEngine === 'openai') {
      return this.translateWithOpenAI(texts, sourceLang, targetLang, settings.customAPIKey!);
    }

    // 其他引擎...
    throw new Error(`Engine ${settings.preferredEngine} not supported with custom key`);
  },

  // OpenAI 翻译
  async translateWithOpenAI(
    texts: string[],
    sourceLang: string,
    targetLang: string,
    apiKey: string
  ): Promise<{ original: string; translated: string }[]> {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4-turbo-preview',
        messages: [
          {
            role: 'system',
            content: `Translate from ${sourceLang} to ${targetLang}. Return JSON array of translations.`,
          },
          {
            role: 'user',
            content: JSON.stringify(texts),
          },
        ],
        temperature: 0.3,
      }),
    });

    const data = await response.json();
    const content = data.choices[0]?.message?.content || '[]';
    
    try {
      const translated: string[] = JSON.parse(content);
      return texts.map((original, i) => ({
        original,
        translated: translated[i] || original,
      }));
    } catch {
      return texts.map(original => ({ original, translated: original }));
    }
  },
};
```

### 4.3 设置页面集成

```tsx
// entrypoints/options/components/TranslationSettings.tsx
import React, { useState, useEffect } from 'react';
import { storage } from 'wxt/storage';
import { memberTranslationService } from '@/services/memberTranslation';

interface TranslationSettings {
  useMemberAPI: boolean;
  customAPIKey?: string;
  preferredEngine: string;
}

export function TranslationSettings() {
  const [settings, setSettings] = useState<TranslationSettings>({
    useMemberAPI: true,
    preferredEngine: 'openai',
  });
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [usage, setUsage] = useState<{
    tier: string;
    dailyRemaining: number;
    monthlyRemaining: number;
  } | null>(null);
  const [engines, setEngines] = useState<{ id: string; name: string; available: boolean }[]>([]);

  useEffect(() => {
    loadData();
  }, []);

  async function loadData() {
    // 加载设置
    const saved = await storage.getItem<TranslationSettings>('local:translation_settings');
    if (saved) setSettings(saved);

    // 检查认证状态
    const auth = await memberTranslationService.isAuthenticated();
    setIsAuthenticated(auth);

    if (auth) {
      // 获取使用情况
      const usage = await memberTranslationService.getUsage();
      setUsage(usage);

      // 获取可用引擎
      const engines = await memberTranslationService.getAvailableEngines();
      setEngines(engines);
    }
  }

  async function saveSettings(newSettings: TranslationSettings) {
    setSettings(newSettings);
    await storage.setItem('local:translation_settings', newSettings);
  }

  return (
    <div className="space-y-6">
      <h2 className="text-xl font-semibold">Translation Settings</h2>

      {/* 会员状态 */}
      {isAuthenticated ? (
        <div className="p-4 bg-green-50 border border-green-200 rounded-lg">
          <div className="flex items-center justify-between">
            <div>
              <p className="font-medium text-green-800">
                {usage?.tier === 'pro' ? 'Pro Member' : 
                 usage?.tier === 'lifetime' ? 'Lifetime Member' : 'Free Plan'}
              </p>
              {usage && usage.dailyRemaining >= 0 && (
                <p className="text-sm text-green-600">
                  {usage.dailyRemaining.toLocaleString()} characters remaining today
                </p>
              )}
              {usage && usage.dailyRemaining < 0 && (
                <p className="text-sm text-green-600">Unlimited usage</p>
              )}
            </div>
            <a 
              href="https://example.com/pricing" 
              target="_blank"
              className="text-green-700 hover:underline text-sm"
            >
              {usage?.tier === 'free' ? 'Upgrade' : 'Manage'}
            </a>
          </div>
        </div>
      ) : (
        <div className="p-4 bg-slate-50 border border-slate-200 rounded-lg">
          <p className="text-slate-600 mb-2">
            Sign in to use AI-powered translation without an API key
          </p>
          <a 
            href="https://example.com/auth/signin"
            target="_blank"
            className="inline-block px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700"
          >
            Sign In
          </a>
        </div>
      )}

      {/* 翻译来源选择 */}
      <div className="space-y-4">
        <h3 className="font-medium">Translation Source</h3>

        <label className="flex items-start space-x-3 p-4 border rounded-lg cursor-pointer hover:bg-slate-50">
          <input
            type="radio"
            name="source"
            checked={settings.useMemberAPI}
            onChange={() => saveSettings({ ...settings, useMemberAPI: true, customAPIKey: undefined })}
            className="mt-1"
            disabled={!isAuthenticated}
          />
          <div>
            <p className="font-medium">Use Immersive Translator Service</p>
            <p className="text-sm text-slate-500">
              No configuration needed. Uses our GPT-4 and DeepL APIs.
            </p>
          </div>
        </label>

        <label className="flex items-start space-x-3 p-4 border rounded-lg cursor-pointer hover:bg-slate-50">
          <input
            type="radio"
            name="source"
            checked={!settings.useMemberAPI}
            onChange={() => saveSettings({ ...settings, useMemberAPI: false })}
            className="mt-1"
          />
          <div>
            <p className="font-medium">Use Your Own API Key</p>
            <p className="text-sm text-slate-500">
              Enter your OpenAI or DeepL API key.
            </p>
          </div>
        </label>

        {/* 自定义API Key输入 */}
        {!settings.useMemberAPI && (
          <div className="ml-6 space-y-4">
            <div>
              <label className="block text-sm font-medium mb-1">API Key</label>
              <input
                type="password"
                value={settings.customAPIKey || ''}
                onChange={(e) => saveSettings({ ...settings, customAPIKey: e.target.value })}
                placeholder="sk-..."
                className="w-full px-3 py-2 border rounded-lg"
              />
            </div>
          </div>
        )}
      </div>

      {/* 翻译引擎选择 */}
      {settings.useMemberAPI && isAuthenticated && engines.length > 0 && (
        <div className="space-y-4">
          <h3 className="font-medium">Preferred Engine</h3>
          <div className="grid grid-cols-2 gap-4">
            {engines.map(engine => (
              <label
                key={engine.id}
                className={`flex items-center space-x-3 p-4 border rounded-lg cursor-pointer 
                  ${!engine.available ? 'opacity-50 cursor-not-allowed' : 'hover:bg-slate-50'}
                  ${settings.preferredEngine === engine.id ? 'border-purple-500 bg-purple-50' : ''}`}
              >
                <input
                  type="radio"
                  name="engine"
                  value={engine.id}
                  checked={settings.preferredEngine === engine.id}
                  onChange={() => saveSettings({ ...settings, preferredEngine: engine.id })}
                  disabled={!engine.available}
                />
                <div>
                  <p className="font-medium">{engine.name}</p>
                  {!engine.available && (
                    <p className="text-xs text-slate-500">Requires Pro</p>
                  )}
                </div>
              </label>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
```

## 5. 数据库 Schema 补充

```typescript
// src/db/schema/translation.ts
import { pgTable, text, timestamp, integer, uuid, index } from 'drizzle-orm/pg-core';

// 翻译缓存表
export const translationCache = pgTable('translation_cache', {
  id: uuid('id').primaryKey().defaultRandom(),
  sourceHash: text('source_hash').notNull(),
  sourceText: text('source_text'), // 用于调试,可选
  translatedText: text('translated_text').notNull(),
  sourceLang: text('source_lang'),
  targetLang: text('target_lang').notNull(),
  engine: text('engine').notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
}, (table) => ({
  hashLangEngineIdx: index('hash_lang_engine_idx')
    .on(table.sourceHash, table.targetLang, table.engine),
}));

// 用户表添加使用量字段
// 在 users 表中添加:
// dailyCharactersUsed: integer('daily_characters_used').default(0),
// monthlyCharactersUsed: integer('monthly_characters_used').default(0),
// lastUsageReset: timestamp('last_usage_reset'),
```

## 总结

本章节完成了:

1. **会员权限系统** - 基于订阅状态的功能限制
2. **使用量跟踪** - 每日/每月字符数限制
3. **AI翻译服务** - OpenAI GPT-4 和 DeepL 集成
4. **翻译缓存** - 减少重复API调用
5. **统一翻译接口** - 会员API / 自定义Key / 免费服务自动切换
6. **插件端集成** - 无缝对接后端服务

会员用户享受:
- 无限翻译字符数
- GPT-4 高质量翻译
- DeepL 专业翻译
- PDF 批量翻译
- 无需配置 API Key
